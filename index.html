<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Meteor Dodge 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #fff;
        }

        #canvasContainer {
            position: fixed;
            inset: 0;
        }

        canvas {
            display: block;
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.55);
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
        }

        #hud h1 {
            margin: 0 0 4px 0;
            font-size: 18px;
            font-weight: 600;
        }

        #groupInfo {
            font-size: 12px;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        #modeToggle {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
            pointer-events: auto;
        }

        #modeToggle button {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            background: #222;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        #modeToggle button.active {
            background: #4caf50;
            border-color: #4caf50;
        }

        #scoreDisplay {
            font-size: 13px;
            margin-bottom: 4px;
        }

        #statusMessage {
            font-size: 13px;
            color: #ffcc66;
            min-height: 1.2em;
            max-width: 260px;
        }

        #controls {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 120px;
            height: 120px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            pointer-events: auto;
        }

        #controls button {
            border: 1px solid #666;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
        }

        #controls button:active {
            background: #4caf50;
        }

        #controls button.empty {
            visibility: hidden;
        }

        #instructions {
            position: fixed;
            bottom: 12px;
            left: 12px;
            max-width: 320px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 8px;
            border-radius: 6px;
            line-height: 1.3;
        }

        @media (max-width: 600px) {
            #hud {
                font-size: 12px;
            }
            #hud h1 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>

    <div id="hud">
        <h1>Meteor Dodge 3D</h1>
        <div id="groupInfo">
            <!-- TODO: replace with your real group name and ID -->
            Group: Awesome Meteors • ID: <strong>1234</strong>
        </div>

        <div id="modeToggle">
            <span style="font-size:12px;">Mode:</span>
            <button id="btnPrototype" class="active">Prototype</button>
            <button id="btnFull">Full</button>
        </div>
        
        <div id="modeToggle">
            <span style="font-size:12px;">AI:</span>
            <button id="btnAI">OFF</button>
        </div>
        <div id="aiFeatures" style="margin-top:4px; font-size:11px; pointer-events:auto;">
            <label style="display:block;">
                <input type="checkbox" id="chkHoleAvoid" checked>
                Hole avoidance
            </label>
            <label style="display:block; margin-top:2px;">
                <input type="checkbox" id="chkThinkingTime" checked>
                Thinking time
            </label>
        </div>

        <div id="scoreDisplay">Score: 0.0</div>
        <div id="statusMessage"></div>
        <div id="aiLevelDisplay" style="font-size:12px; margin-top:4px; opacity:0.8;">AI Level: 5 (Intermediate)</div>
    </div>

    <div id="controls">
        <button class="empty"></button>
        <button data-dir="up">▲</button>
        <button class="empty"></button>

        <button data-dir="left">◀</button>
        <button class="empty"></button>
        <button data-dir="right">▶</button>

        <button class="empty"></button>
        <button data-dir="down">▼</button>
        <button class="empty"></button>
    </div>

    <div id="instructions">
        Keyboard: WASD / Arrow keys to move, R to restart.<br />
        AI: Press I to toggle, [ ] to adjust level (1-10).<br />
        Mobile: use the on-screen arrows and AI button.
    </div>

    <!-- THREE & loaders from CDN (r126 pattern from StackOverflow answer; examples/js loaders attach to THREE) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/OBJLoader.js"></script>
    
    <!-- AI Computer Player -->
    <script src="computer.js"></script>

    <script>
    window.addEventListener("load", function () {
        // ------------------------------------------------------------
        // Global state
        // ------------------------------------------------------------
        let scene, camera, renderer;

        let player = null;
        let meteors = [];
        let meteorShadows = []; // NEW: shadow disk for each meteor
        let platform = null;
        let skySphere = null;
        let walls = [];
        let holes = []; // {mesh, x, z, halfSize}

        const moveState = {
            left: false,
            right: false,
            forward: false,
            backward: false
        };

        let isPrototypeMode = true;
        let isGameOver = false;
        let isFalling = false;
        let score = 0;
        let lastTime = 0;
        let useAI = false; // Toggle for AI control
        let aiLevel = 5; // AI difficulty level (1-10)
        const meteorCount = 24;
        const worldSize = 28;  // bigger arena
        const playerSpeed = 12;
        const baseMeteorSpeed = 8;
        const fallSpeed = 15;
        const fallThreshold = -5;
        
        // Holes positions (x, z, halfSize) - shared between platform and collision detection
        const holeSpecs = [
            { x: -6, z: 6, halfSize: 2.5 },
            { x: 8,  z: -2, halfSize: 2.2 },
            { x: 0,  z: -8, halfSize: 3.0 }
        ];
        
        // Create AI instance
        const computerAI = new ComputerAI();

        let textureLoader;
        let gltfLoader;
        let mtlLoader;
        let objLoader;
        let asteroidTemplate = null; // loaded OBJ for full-mode meteors
        let rocketShipTemplate = null; // loaded OBJ for player
        
        // Simple texture cache
        const textures = {
            rocketBase: null,
            asteroidColor: null,
            asteroidNormal: null
        };

        const scoreDisplay = document.getElementById("scoreDisplay");
        const statusMessage = document.getElementById("statusMessage");
        const aiLevelDisplay = document.getElementById("aiLevelDisplay");
        const btnPrototype = document.getElementById("btnPrototype");
        const btnFull = document.getElementById("btnFull");
        const btnAI = document.getElementById("btnAI");
        const chkHoleAvoid = document.getElementById("chkHoleAvoid");
        const chkThinkingTime = document.getElementById("chkThinkingTime");
        const canvasContainer = document.getElementById("canvasContainer");

        // Camera-aligned movement basis
        const camForward = new THREE.Vector3();
        const camRight = new THREE.Vector3();
        const tmpDir = new THREE.Vector3();
        const worldUp = new THREE.Vector3(0, 1, 0);

        init();
        animate(0);

        // ------------------------------------------------------------
        // Initialization
        // ------------------------------------------------------------
        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050818);
            canvasContainer.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                200
            );
            // fixed 2.5D angle (corner view)
            camera.position.set(26, 24, 26);
            camera.lookAt(0, 0, 0);
            computeCameraBasis();

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(16, 26, 10);
            scene.add(dirLight);

            textureLoader = new THREE.TextureLoader();
            initTextures();

            if (typeof THREE !== "undefined" && THREE.GLTFLoader) {
                gltfLoader = new THREE.GLTFLoader();
            } else if (typeof GLTFLoader !== "undefined") {
                gltfLoader = new GLTFLoader();
            } else {
                console.warn("GLTFLoader not found; full mode will use fallback player.");
                gltfLoader = null;
            }

            // OBJ / MTL loaders for asteroid model in full mode
            if (typeof THREE !== "undefined" && THREE.MTLLoader) {
                mtlLoader = new THREE.MTLLoader();
                mtlLoader.setPath("assets/");
            } else if (typeof MTLLoader !== "undefined") {
                mtlLoader = new MTLLoader();
                mtlLoader.setPath("assets/");
            } else {
                console.warn("MTLLoader not found; full-mode asteroids will fall back to spheres.");
                mtlLoader = null;
            }

            if (typeof THREE !== "undefined" && THREE.OBJLoader) {
                objLoader = new THREE.OBJLoader();
                objLoader.setPath("assets/");
            } else if (typeof OBJLoader !== "undefined") {
                objLoader = new OBJLoader();
                objLoader.setPath("assets/");
            } else {
                console.warn("OBJLoader not found; full-mode asteroids will fall back to spheres.");
                objLoader = null;
            }

            createBaseWorld();
            setMode(true);
            setupInput();
            window.addEventListener("resize", onWindowResize);
        }

        function initTextures() {
            // Rocket ship base color
            textures.rocketBase = textureLoader.load(
                "assets/Rocketship_baseColor.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Rocketship_baseColor.png");
                }
            );

            // Asteroid textures
            textures.asteroidColor = textureLoader.load(
                "assets/Asteroid2b_Color_1K.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Asteroid2b_Color_1K.png");
                }
            );

            textures.asteroidNormal = textureLoader.load(
                "assets/Asteroid2b_NormalGL_1K.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Asteroid2b_NormalGL_1K.png");
                }
            );
        }

        function computeCameraBasis() {
            // Camera forward in world coordinates
            camera.getWorldDirection(tmpDir);
            // Flatten to XZ plane
            camForward.set(tmpDir.x, 0, tmpDir.z).normalize();        // "up" on screen
            camRight.crossVectors(camForward, worldUp).normalize();   // "right" on screen
        }

        function createBaseWorld() {
            // Create platform with holes cut out
            const half = worldSize * 0.5;
            const shape = new THREE.Shape();
            
            // Define the outer rectangle of the platform
            shape.moveTo(-half, -half);
            shape.lineTo(half, -half);
            shape.lineTo(half, half);
            shape.lineTo(-half, half);
            shape.lineTo(-half, -half);
            
            // Create hole paths
            // Platform is rotated -90° around X, so shape coordinates map as:
            // shape X → world X, shape Y → world -Z
            const holePaths = holeSpecs.map(h => {
                const hole = new THREE.Path();
                const x = h.x;
                const y = -h.z; // z in 3D world becomes -y in 2D shape (due to rotation)
                hole.moveTo(x - h.halfSize, y - h.halfSize);
                hole.lineTo(x + h.halfSize, y - h.halfSize);
                hole.lineTo(x + h.halfSize, y + h.halfSize);
                hole.lineTo(x - h.halfSize, y + h.halfSize);
                hole.lineTo(x - h.halfSize, y - h.halfSize);
                return hole;
            });
            
            shape.holes = holePaths;
            
            const geo = new THREE.ShapeGeometry(shape);
            const mat = new THREE.MeshStandardMaterial({ color: 0x777777 });
            platform = new THREE.Mesh(geo, mat);
            platform.rotation.x = -Math.PI / 2;
            platform.receiveShadow = true;
            scene.add(platform);

            // NEW: grid helper on top of the platform for depth cues
            const grid = new THREE.GridHelper(worldSize, 8, 0x444444, 0x333333);
            grid.position.y = 0.02;
            scene.add(grid);

            const skyGeo = new THREE.SphereGeometry(80, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0x050818,
                side: THREE.BackSide
            });
            skySphere = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skySphere);

            createWallsAndHoles();
        }

        function createWallsAndHoles() {
            const half = worldSize * 0.5;
            const wallHeight = 2.2;
            const wallThickness = 0.6;
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });

            const wallGeoZ = new THREE.BoxGeometry(worldSize, wallHeight, wallThickness);
            const wallGeoX = new THREE.BoxGeometry(wallThickness, wallHeight, worldSize);

            const north = new THREE.Mesh(wallGeoZ, wallMat);
            north.position.set(0, wallHeight / 2, -half);
            const south = north.clone();
            south.position.z = half;

            const west = new THREE.Mesh(wallGeoX, wallMat);
            west.position.set(-half, wallHeight / 2, 0);
            const east = west.clone();
            east.position.x = half;

            [north, south, west, east].forEach(w => {
                scene.add(w);
                walls.push(w);
            });

            // Store hole data for collision detection (holes are cut from platform geometry)
            holeSpecs.forEach(h => {
                holes.push({ mesh: null, x: h.x, z: h.z, halfSize: h.halfSize });
            });
        }

        // ------------------------------------------------------------
        // Mode switching
        // ------------------------------------------------------------
        function setMode(prototype) {
            isPrototypeMode = prototype;
            btnPrototype.classList.toggle("active", prototype);
            btnFull.classList.toggle("active", !prototype);

            resetGameState();
            clearDynamicObjects();

            if (isPrototypeMode) {
                createPrototypePlayerAndMeteors();
                setPrototypeMaterials();
                statusMessage.textContent = "Prototype mode: primitive geometries only.";
            } else {
                createFullPlayerAndMeteors();
                setFullMaterialsAndTextures();
                statusMessage.textContent = "Full mode: using loaded model(s) and textures.";
            }
        }

        function resetGameState() {
            isGameOver = false;
            isFalling = false;
            score = 0;
            scoreDisplay.textContent = "Score: 0.0";
            statusMessage.textContent = "";
            
            // Reset AI path planning
            computerAI.reset();
        }

        function clearDynamicObjects() {
            if (player) {
                scene.remove(player);
                player = null;
            }
            meteors.forEach(m => scene.remove(m));
            meteors = [];

            // NEW: clear shadows
            meteorShadows.forEach(s => scene.remove(s));
            meteorShadows = [];
        }

        function createPrototypePlayerAndMeteors() {
            // Prototype mode uses a simple box
            const playerGeo = new THREE.BoxGeometry(1.5, 1, 2);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.set(0, 1, 0);
            player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
            scene.add(player);

            const meteorGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const shadowGeo = new THREE.CircleGeometry(0.9, 16);

            for (let i = 0; i < meteorCount; i++) {
                const mat = new THREE.MeshStandardMaterial({ color: 0xff6347 });
                const mesh = new THREE.Mesh(meteorGeo, mat);
                resetMeteorPosition(mesh, true);
                scene.add(mesh);
                meteors.push(mesh);

                // NEW: shadow disk
                const shadowMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.35
                });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                scene.add(shadow);
                meteorShadows.push(shadow);
            }
        }

        function createFullPlayerAndMeteors() {
            // --- Player (rocket) ---
            if (rocketShipTemplate) {
                // Already loaded once – just clone
                player = rocketShipTemplate.clone();
                applyRocketMaterials(player);
                player.scale.set(1.5, 1.5, 1.5);
                player.position.set(0, 1, 0);
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
            } else if (mtlLoader && objLoader) {
                // Load rocket from OBJ/MTL once
                const fallbackPlayer = createFallbackFullPlayer();
                player = fallbackPlayer;
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
                
                mtlLoader.load(
                    "cartoon_rocket_ship.mtl",
                    function (materials) {
                        materials.preload();
                        objLoader.setMaterials(materials);
                        objLoader.load(
                            "cartoon_rocket_ship.obj",
                            function (obj) {
                                rocketShipTemplate = obj;
                                if (player) scene.remove(player);

                                player = rocketShipTemplate.clone();
                                applyRocketMaterials(player);
                                player.scale.set(1.5, 1.5, 1.5);
                                player.position.set(0, 1, 0);
                                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                                scene.add(player);
                            },
                            undefined,
                            function (err) {
                                console.warn("Could not load rocket ship OBJ, using fallback player.", err);
                            }
                        );
                    },
                    undefined,
                    function (err) {
                        console.warn("Could not load rocket ship MTL, using fallback player.", err);
                    }
                );
            } else {
                // No loaders – use basic cylinder+cone
                const fallbackPlayer = createFallbackFullPlayer();
                player = fallbackPlayer;
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
            }

            // --- Meteors + shadows ---
            const shadowGeo = new THREE.CircleGeometry(0.9, 16);

            function spawnMeteorFromPrototype(prototype) {
                const mesh = prototype.clone();
                mesh.traverse(obj => {
                    if (obj.isMesh) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                });

                mesh.rotation.x = Math.random() * Math.PI * 2;
                mesh.rotation.y = Math.random() * Math.PI * 2;
                mesh.rotation.z = Math.random() * Math.PI * 2;

                const scale = Math.random() * 0.2 + 0.8;
                mesh.scale.set(scale, scale, scale);

                resetMeteorPosition(mesh, true);
                scene.add(mesh);
                meteors.push(mesh);

                const shadowMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.35
                });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                scene.add(shadow);
                meteorShadows.push(shadow);
            }

            // If we already have the asteroid OBJ, just clone it
            if (asteroidTemplate) {
                for (let i = 0; i < meteorCount; i++) {
                    spawnMeteorFromPrototype(asteroidTemplate);
                }
                return;
            }

            // Try to load asteroid OBJ/MTL once
            if (mtlLoader && objLoader) {
                mtlLoader.load(
                    "Asteroid_2b.mtl",
                    function (materials) {
                        materials.preload();
                        objLoader.setMaterials(materials);
                        objLoader.load(
                            "Asteroid_2b.obj",
                            function (obj) {
                                asteroidTemplate = obj;
                                applyAsteroidMaterials(asteroidTemplate);
                                for (let i = 0; i < meteorCount; i++) {
                                    spawnMeteorFromPrototype(asteroidTemplate);
                                }
                            },
                            undefined,
                            function (err) {
                                console.warn("Could not load asteroid OBJ, falling back to sphere asteroids.", err);
                                createFallbackRockMeteors();
                            }
                        );
                    },
                    undefined,
                    function (err) {
                        console.warn("Could not load asteroid MTL, falling back to sphere asteroids.", err);
                        createFallbackRockMeteors();
                    }
                );
            } else {
                // No loaders – sphere asteroids with textures
                createFallbackRockMeteors();
            }

            // Fallback: textured spheres using asteroid PNGs
            function createFallbackRockMeteors() {
                const meteorGeo = new THREE.SphereGeometry(0.8, 24, 24);

                for (let i = 0; i < meteorCount; i++) {
                    const mat = new THREE.MeshStandardMaterial({
                        map: textures.asteroidColor || null,
                        normalMap: textures.asteroidNormal || null,
                        metalness: 0.1,
                        roughness: 0.9
                    });

                    const mesh = new THREE.Mesh(meteorGeo, mat);
                    resetMeteorPosition(mesh, true);
                    scene.add(mesh);
                    meteors.push(mesh);

                    const shadowMat = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.35
                    });
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.rotation.x = -Math.PI / 2;
                    shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                    scene.add(shadow);
                    meteorShadows.push(shadow);
                }
            }
        }

        function createFallbackFullPlayer() {
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.8, 2.2, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00bcd4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);

            const noseGeo = new THREE.ConeGeometry(0.5, 1.0, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.y = 1.5;

            const group = new THREE.Group();
            group.add(body);
            group.add(nose);
            group.position.set(0, 1, 0);
            return group;
        }

        function applyRocketMaterials(root) {
            root.traverse(obj => {
                if (!obj.isMesh) return;

                obj.castShadow = true;
                obj.receiveShadow = true;

                if (textures.rocketBase) {
                    obj.material = new THREE.MeshStandardMaterial({
                        map: textures.rocketBase,
                        metalness: 0.3,
                        roughness: 0.6
                    });
                } else if (obj.material) {
                    obj.material = obj.material.clone();
                }
            });
        }

        function applyAsteroidMaterials(root) {
            root.traverse(obj => {
                if (!obj.isMesh) return;

                obj.castShadow = true;
                obj.receiveShadow = true;

                obj.material = new THREE.MeshStandardMaterial({
                    map: textures.asteroidColor || null,
                    normalMap: textures.asteroidNormal || null,
                    metalness: 0.1,
                    roughness: 0.9
                });
            });
        }

        function setPrototypeMaterials() {
            if (platform && platform.material) {
                // Gray floor in prototype mode
                platform.material = new THREE.MeshStandardMaterial({ color: 0x777777 });
            }
            if (skySphere && skySphere.material) {
                skySphere.material = new THREE.MeshBasicMaterial({
                    color: 0x050818,
                    side: THREE.BackSide
                });
            }
        }

        function setFullMaterialsAndTextures() {
            if (platform && platform.material) {
                platform.material = new THREE.MeshStandardMaterial({
                    color: 0x999999,   // light gray floor color
                    metalness: 0.55,  // a bit more reflective
                    roughness: 0.45   // slightly smoother surface
                });
            }

            if (skySphere && skySphere.material) {
                skySphere.material = new THREE.MeshBasicMaterial({
                    color: 0x050818,
                    side: THREE.BackSide
                });
            }
        }

        // ------------------------------------------------------------
        // Input handling
        // ------------------------------------------------------------
        function setupInput() {
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);

            btnPrototype.addEventListener("click", () => setMode(true));
            btnFull.addEventListener("click", () => setMode(false));
            btnAI.addEventListener("click", toggleAI);

            // AI feature toggles
            if (chkHoleAvoid) {
                chkHoleAvoid.addEventListener("change", () => {
                    computerAI.setHoleAvoidanceEnabled(chkHoleAvoid.checked);
                });
            }
            if (chkThinkingTime) {
                chkThinkingTime.addEventListener("change", () => {
                    computerAI.setThinkingTimeEnabled(chkThinkingTime.checked);
                });
            }

            const controlButtons = document.querySelectorAll("#controls button[data-dir]");
            controlButtons.forEach(btn => {
                const dir = btn.getAttribute("data-dir");

                function pressHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, true);
                }

                function releaseHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, false);
                }

                btn.addEventListener("mousedown", pressHandler);
                btn.addEventListener("mouseup", releaseHandler);
                btn.addEventListener("mouseleave", releaseHandler);

                btn.addEventListener("touchstart", pressHandler, { passive: false });
                btn.addEventListener("touchend", releaseHandler, { passive: false });
                btn.addEventListener("touchcancel", releaseHandler, { passive: false });
            });
        }

        function onKeyDown(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = true;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = true;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = true;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = true;

            if (e.key === "r" || e.key === "R") {
                resetGameState();
                clearDynamicObjects();
                if (isPrototypeMode) {
                    createPrototypePlayerAndMeteors();
                    setPrototypeMaterials();
                } else {
                    createFullPlayerAndMeteors();
                    setFullMaterialsAndTextures();
                }
            }
            
            if (e.key === "i" || e.key === "I") {
                useAI = !useAI;
                updateAIStatus();
            }
            
            // AI level controls
            if (e.key === "[" || e.key === "{") {
                aiLevel = Math.max(1, aiLevel - 1);
                updateAIStatus();
            }
            if (e.key === "]" || e.key === "}") {
                aiLevel = Math.min(10, aiLevel + 1);
                updateAIStatus();
            }
        }

        function onKeyUp(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = false;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = false;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = false;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = false;
        }

        function setMoveState(dir, value) {
            if (dir === "left") moveState.left = value;
            if (dir === "right") moveState.right = value;
            if (dir === "up") moveState.forward = value;
            if (dir === "down") moveState.backward = value;
        }
        
        function toggleAI() {
            useAI = !useAI;
            updateAIStatus();
        }
        
        function updateAIStatus() {
            btnAI.textContent = useAI ? "ON" : "OFF";
            btnAI.classList.toggle("active", useAI);
            
            // Update AI level display
            const levelDesc = getLevelDescription(aiLevel);
            aiLevelDisplay.textContent = `AI Level: ${aiLevel} (${levelDesc})`;
            
            if (useAI) {
                statusMessage.textContent = `AI ACTIVE - Press [ ] to adjust level, I to disable`;
                statusMessage.style.color = "#4caf50";
            } else {
                statusMessage.textContent = "Manual control - Press I to enable AI";
                statusMessage.style.color = "#ffcc66";
            }
        }
        
        function getLevelDescription(level) {
            if (level <= 3) return "Beginner";
            if (level <= 6) return "Intermediate";
            if (level <= 9) return "Advanced";
            return "Expert";
        }

        // ------------------------------------------------------------
        // Game loop
        // ------------------------------------------------------------
        function animate(timestamp) {
            requestAnimationFrame(animate);

            const t = timestamp * 0.001;
            const delta = lastTime ? t - lastTime : 0;
            lastTime = t;

            // Always update player (handles falling even when game over)
            updatePlayer(delta);
            
            if (!isGameOver) {
                checkCollisions();

                score += delta;
                scoreDisplay.textContent = "Score: " + score.toFixed(1);
            }
            
            // Always update meteors (even when game over)
            updateMeteors(delta);

            renderer.render(scene, camera);
        }

        function updatePlayer(delta) {
            if (!player) return;

            // Check if entire player body is in hole - game over immediately (no movement allowed)
            const playerRadius = 0.9;
            if (!isGameOver && isFullyInHole(player.position.x, player.position.z, playerRadius)) {
                isGameOver = true;
                isFalling = true;
            }

            // Disable movement when game over
            if (isGameOver) {
                // Continue falling if already falling
                if (isFalling) {
                    player.position.y -= fallSpeed * delta;
                    if (player.position.y < -2 && !statusMessage.textContent.includes("Game over")) {
                        const base = "Game over! Final score " + score.toFixed(1) + ".";
                        statusMessage.textContent = base + " You fell into a hole! Press R or switch mode to restart.";
                    }
                }
                return;
            }

            // Input in "screen" space: ix = left/right, iz = up/down (forward/back)
            let ix = 0;
            let iz = 0;
            
            // Use AI if enabled, otherwise use manual controls
            if (useAI) {
                // Calculate current meteor fall speed
                const speedBoost = score * 0.15;
                const meteorFallSpeed = baseMeteorSpeed + speedBoost;
                
                // Prepare meteor data with velocity for AI
                const meteorData = meteors.map(m => ({
                    position: { 
                        x: m.position.x, 
                        y: m.position.y, 
                        z: m.position.z 
                    },
                    velocity: {
                        x: 0,
                        y: -meteorFallSpeed, // Meteors fall straight down
                        z: 0
                    }
                }));
                
                // Get AI's suggested move with difficulty level (returns world-space dx/dz)
                const move = computerAI.suggestMove(meteorData, {
                    x: player.position.x,
                    y: player.position.y,
                    z: player.position.z
                }, score, aiLevel);
                
                // Convert AI's world-space movement (dx, dz) to camera-aligned (ix, iz)
                // AI returns movement in world coordinates: dx = world X, dz = world Z
                // We need to project this onto camera basis vectors
                const worldDx = move.dx || 0;
                const worldDz = move.dz || 0;
                
                // Project world movement onto camera right and forward vectors
                // ix = component along camRight, iz = component along camForward
                ix = worldDx * camRight.x + worldDz * camRight.z;
                iz = worldDx * camForward.x + worldDz * camForward.z;
            } else {
                // Manual controls
                if (moveState.left)  ix -= 1;
                if (moveState.right) ix += 1;
                if (moveState.forward)  iz += 1;   // W / ArrowUp -> move "up" on screen
                if (moveState.backward) iz -= 1;   // S / ArrowDown -> move "down" on screen
            }

            // If no input, return to neutral tilt and exit
            if (ix === 0 && iz === 0) {
                const maxTilt = 0.35;
                player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, 0, 0.15);
                player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.15);
                return;
            }

            // normalize
            const len = Math.sqrt(ix * ix + iz * iz);
            ix /= len;
            iz /= len;

            // world movement based on camera basis:
            // right/left along camRight, up/down along camForward
            const worldMove = new THREE.Vector3();
            worldMove.copy(camRight).multiplyScalar(ix);
            worldMove.addScaledVector(camForward, iz);

            const dist = playerSpeed * delta;
            const newX = player.position.x + worldMove.x * dist;
            const newZ = player.position.z + worldMove.z * dist;

            const half = worldSize * 0.5 - 1.0;
            player.position.x = THREE.MathUtils.clamp(newX, -half, half);
            player.position.z = THREE.MathUtils.clamp(newZ, -half, half);

            // Tilt in the direction of movement (only when actually moving)
            const maxTilt = 0.35;
            const normalizedMove = new THREE.Vector3(worldMove.x, 0, worldMove.z).normalize();
            // Tilt forward/backward based on Z movement, left/right based on X movement
            // Forward (Z+) → tilt forward (rotation.x+), Backward (Z-) → tilt backward (rotation.x-)
            // Left (X-) → tilt left (rotation.z+), Right (X+) → tilt right (rotation.z-)
            const targetTiltX = THREE.MathUtils.clamp(normalizedMove.z * maxTilt, -maxTilt, maxTilt);
            const targetTiltZ = THREE.MathUtils.clamp(-normalizedMove.x * maxTilt, -maxTilt, maxTilt);
            
            player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, targetTiltX, 0.15);
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, targetTiltZ, 0.15);
        }

        function updateMeteors(delta) {
            const speedBoost = score * 0.15;
            const fallSpeed = baseMeteorSpeed + speedBoost;

            for (let i = 0; i < meteors.length; i++) {
                const m = meteors[i];
                const s = meteorShadows[i];

                m.position.y -= fallSpeed * delta;
                m.rotation.x += 0.8 * delta;
                m.rotation.y += 0.5 * delta;

                if (m.position.y < -4) {
                    resetMeteorPosition(m, false);
                }

                // NEW: update shadow position/scale/opacity
                if (s) {
                    s.position.x = m.position.x;
                    s.position.z = m.position.z;

                    // t = 0 (low) -> big dark shadow; t = 1 (high) -> small faint shadow
                    const t = THREE.MathUtils.clamp((m.position.y - 2) / 18, 0, 1);
                    const scale = THREE.MathUtils.lerp(1.5, 0.4, t);
                    s.scale.set(scale, scale, 1);

                    const mat = s.material;
                    mat.opacity = THREE.MathUtils.lerp(0.55, 0.15, t);
                }
            }
        }

        function resetMeteorPosition(meteor, randomHeight) {
            const half = worldSize * 0.5 - 1.5;
            meteor.position.x = THREE.MathUtils.randFloat(-half, half);
            meteor.position.z = THREE.MathUtils.randFloat(-half, half);
            meteor.position.y = randomHeight
                ? THREE.MathUtils.randFloat(6, 24)
                : THREE.MathUtils.randFloat(14, 26);
        }

        function checkCollisions() {
            if (!player) return;

            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            const playerRadius = 0.9;
            const meteorRadius = 0.8;

            for (const m of meteors) {
                const meteorPos = new THREE.Vector3();
                m.getWorldPosition(meteorPos);

                const dist = playerPos.distanceTo(meteorPos);
                if (dist < playerRadius + meteorRadius) {
                    gameOver("Hit by a meteor!");
                    break;
                }
            }
        }

        function isInHole(x, z) {
            for (const h of holes) {
                if (Math.abs(x - h.x) < h.halfSize &&
                    Math.abs(z - h.z) < h.halfSize) {
                    return true;
                }
            }
            return false;
        }

        function isFullyInHole(x, z, playerRadius) {
            for (const h of holes) {
                // Check if entire player body (center ± radius) is within hole bounds
                const leftEdge = x - playerRadius;
                const rightEdge = x + playerRadius;
                const frontEdge = z - playerRadius;
                const backEdge = z + playerRadius;
                
                const holeLeft = h.x - h.halfSize;
                const holeRight = h.x + h.halfSize;
                const holeFront = h.z - h.halfSize;
                const holeBack = h.z + h.halfSize;
                
                if (leftEdge >= holeLeft && rightEdge <= holeRight &&
                    frontEdge >= holeFront && backEdge <= holeBack) {
                    return true;
                }
            }
            return false;
        }

        function gameOver(reason) {
            if (isGameOver) return;
            isGameOver = true;
            const base = "Game over! Final score " + score.toFixed(1) + ".";
            const reasonText = reason ? " " + reason : "";
            statusMessage.textContent =
                base + reasonText + " Press R or switch mode to restart.";
        }

        // ------------------------------------------------------------
        // Resize
        // ------------------------------------------------------------
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });
    </script>
</body>
</html>
