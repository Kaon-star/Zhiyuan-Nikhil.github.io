<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Meteor Dodge 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #fff;
        }

        #canvasContainer {
            position: fixed;
            inset: 0;
        }

        canvas {
            display: block;
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.55);
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
        }

        #hud h1 {
            margin: 0 0 4px 0;
            font-size: 18px;
            font-weight: 600;
        }

        #groupInfo {
            font-size: 12px;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        #modeToggle {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
            pointer-events: auto;
        }

        #modeToggle button {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            background: #222;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        #modeToggle button.active {
            background: #4caf50;
            border-color: #4caf50;
        }

        #scoreDisplay {
            font-size: 13px;
            margin-bottom: 4px;
        }

        #statusMessage {
            font-size: 13px;
            color: #ffcc66;
            min-height: 1.2em;
            max-width: 260px;
        }

        #controls {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 120px;
            height: 120px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            pointer-events: auto;
        }

        #controls button {
            border: 1px solid #666;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
        }

        #controls button:active {
            background: #4caf50;
        }

        #controls button.empty {
            visibility: hidden;
        }

        #instructions {
            position: fixed;
            bottom: 12px;
            left: 12px;
            max-width: 320px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 8px;
            border-radius: 6px;
            line-height: 1.3;
        }

        @media (max-width: 600px) {
            #hud {
                font-size: 12px;
            }
            #hud h1 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>

    <div id="hud">
        <h1>Meteor Dodge 3D</h1>
        <div id="groupInfo">
            <!-- TODO: replace with your real group name and ID -->
            Group: Awesome Meteors • ID: <strong>1234</strong>
        </div>

        <div id="modeToggle">
            <span style="font-size:12px;">Mode:</span>
            <button id="btnPrototype">Prototype</button>
            <button id="btnFull" class="active">Full</button>
        </div>

        <div id="modeToggle">
            <span style="font-size:12px;">AI:</span>
            <button id="btnAI">OFF</button>
        </div>
        <div id="aiFeatures" style="margin-top:4px; font-size:11px; pointer-events:auto;">
            <label style="display:block;">
                <input type="checkbox" id="chkHoleAvoid" checked>
                Hole avoidance
            </label>
            <label style="display:block; margin-top:2px;">
                <input type="checkbox" id="chkThinkingTime" checked>
                Thinking time
            </label>
            <label style="display:block; margin-top:2px;">
                <input type="checkbox" id="chkEnemyAvoid" checked>
                Enemy avoidance
            </label>
        </div>

        <div id="scoreDisplay">Score: 0.0</div>
        <div id="statusMessage"></div>
        <div id="aiLevelDisplay" style="font-size:12px; margin-top:4px; opacity:0.8;">
            AI Level: 5 (Intermediate)
        </div>
    </div>

    <div id="controls">
        <button class="empty"></button>
        <button data-dir="up">▲</button>
        <button class="empty"></button>

        <button data-dir="left">◀</button>
        <button class="empty"></button>
        <button data-dir="right">▶</button>

        <button class="empty"></button>
        <button data-dir="down">▼</button>
        <button class="empty"></button>
    </div>

    <div id="instructions">
        Keyboard: WASD / Arrow keys to move, R to restart.<br />
        AI: Press I to toggle, [ ] to adjust level (1-10).<br />
        Mobile: use the on-screen arrows and AI button.
    </div>

    <!-- THREE & loaders (keep your versions for OBJ/MTL compatibility) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/OBJLoader.js"></script>

    <!-- AI Computer Player -->
    <script src="computer.js"></script>

    <script>
    window.addEventListener("load", function () {
        // ------------------------------------------------------------
        // Global state
        // ------------------------------------------------------------
        let scene, camera, renderer;

        let player = null;
        let rocketExhaust = null; // Particle system for rocket exhaust

        // Meteors + shadows
        let meteors = [];
        let meteorShadows = [];
        let asteroidTemplate = null; // loaded OBJ for full-mode meteors
        
        // Enemies
        let alienTemplate = null; // loaded OBJ for enemies
        let alienTemplateLoading = false; // track if alien model is currently loading
        let maxRequestedEnemyCount = 0; // track maximum enemy count requested while loading
        
        // Meteor collision animation state
        let meteorAnimations = []; // Array to track which meteors are animating
        const meteorAnimationDuration = 0.5; // seconds for collision animation
        
        // Pre-baked explosion debris system
        let debrisPool = []; // Pool of pre-created debris pieces
        let activeDebris = []; // Currently active debris pieces with animation data
        const debrisCount = 20; // Number of debris pieces per explosion
        const debrisPoolSize = 200; // Total pool size (supports ~10 simultaneous explosions)
        const debrisLifetime = 2.0; // How long debris stays visible (seconds)

        // Enemies (aliens)
        let enemies = [];
        let activeEnemyCount = 0;

        // Infinite floor
        let floorGroup = null;
        let floorTiles = [];
        let gridHelper = null;
        let skySphere = null;

        // Holes are dynamic (for visible tiles only)
        // Each entry: { x, z, halfSize }
        let holes = [];
        let holeMeshes = []; // visuals for holes (pooled per tile)

        const moveState = {
            left: false,
            right: false,
            forward: false,
            backward: false
        };

        let isPrototypeMode = false;
        let isGameOver = false;
        let isFalling = false;
        
        // Black hole animation state
        let blackHoleAnimationStartTime = 0;
        let initialPlayerScale = new THREE.Vector3(1, 1, 1);
        let blackHoleTargetPos = new THREE.Vector3(); // Center of the black hole

        let score = 0;
        let lastTime = 0;
        let gameStartTime = 0; // Track when current game started
        
        // Player velocity tracking
        let playerVelocityX = 0;
        let playerVelocityZ = 0;
        let lastPlayerX = 0;
        let lastPlayerZ = 0;

        // AI
        let useAI = false;
        let aiLevel = 5;
        const computerAI = new ComputerAI();

        // Loaders
        let textureLoader;
        let gltfLoader;
        let mtlLoader;
        let objLoader;
        let rocketShipTemplate = null; // loaded OBJ for player
        
        // Simple texture cache
        const textures = {
            rocketBase: null,
            asteroidColor: null,
            asteroidNormal: null,
            galaxy: null
        };

        // UI
        const scoreDisplay = document.getElementById("scoreDisplay");
        const statusMessage = document.getElementById("statusMessage");
        const aiLevelDisplay = document.getElementById("aiLevelDisplay");
        const btnPrototype = document.getElementById("btnPrototype");
        const btnFull = document.getElementById("btnFull");
        const btnAI = document.getElementById("btnAI");
        const chkHoleAvoid = document.getElementById("chkHoleAvoid");
        const chkThinkingTime = document.getElementById("chkThinkingTime");
        const chkEnemyAvoid = document.getElementById("chkEnemyAvoid");
        const canvasContainer = document.getElementById("canvasContainer");

        // Camera-aligned movement basis
        const camForward = new THREE.Vector3();
        const camRight = new THREE.Vector3();
        const tmpDir = new THREE.Vector3();
        const worldUp = new THREE.Vector3(0, 1, 0);

        const tmpV1 = new THREE.Vector3();

        // ------------------------------------------------------------
        // Performance / infinite arena config
        // ------------------------------------------------------------
        const tileSize = 32;
        const tileRadius = 1; // 3x3 tiles

        // Movement
        const playerSpeed = 12;

        // Black hole animation
        const blackHoleAnimationDuration = 2.0; // seconds to complete animation
        const blackHoleSpinSpeed = 3.0; // rotations per second

        // Meteors scaling
        const baseMeteorCount = 24;
        const maxMeteorCount  = 90 * 4;
        const baseMeteorSpeed = 8;

        // Enemies scaling
        const enemyStartTime = 8; // seconds before first enemy
        const maxEnemyCount = 18;

        // Spawn radii relative to player
        const meteorSpawnRadiusMin = 6; 
        const meteorSpawnRadiusMax = 18 * 4;
        const enemySpawnRadiusMin = 12;
        const enemySpawnRadiusMax = 22;

        // Camera follow
        const cameraOffset = new THREE.Vector3(26, 24, 26);
        const cameraTargetPos = new THREE.Vector3();
        const cameraLookAtPos = new THREE.Vector3();

        init();
        animate(0);

        // ------------------------------------------------------------
        // Initialization
        // ------------------------------------------------------------
        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x4a148c); // Purple background
            canvasContainer.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                240
            );
            camera.position.set(26, 24, 26);
            camera.lookAt(0, 0, 0);
            computeCameraBasis();

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(16, 26, 10);
            scene.add(dirLight);

            textureLoader = new THREE.TextureLoader();
            initTextures();

            gltfLoader = (typeof THREE.GLTFLoader !== "undefined") ? new THREE.GLTFLoader() : null;
            
            // OBJ / MTL loaders for asteroid and rocket models in full mode
            if (typeof THREE !== "undefined" && THREE.MTLLoader) {
                mtlLoader = new THREE.MTLLoader();
                mtlLoader.setPath("assets/");
            } else if (typeof MTLLoader !== "undefined") {
                mtlLoader = new MTLLoader();
                mtlLoader.setPath("assets/");
            } else {
                console.warn("MTLLoader not found; full-mode models will fall back to primitives.");
                mtlLoader = null;
            }

            if (typeof THREE !== "undefined" && THREE.OBJLoader) {
                objLoader = new THREE.OBJLoader();
                objLoader.setPath("assets/");
            } else if (typeof OBJLoader !== "undefined") {
                objLoader = new OBJLoader();
                objLoader.setPath("assets/");
            } else {
                console.warn("OBJLoader not found; full-mode models will fall back to primitives.");
                objLoader = null;
            }

            createSky();
            createInfiniteFloor(); // Creates black holes (no floor)
            createDebrisPool(); // Pre-bake debris pieces
            setMode(false);
            setupInput();

            window.addEventListener("resize", onWindowResize);
        }

        function initTextures() {
            // Rocket ship base color
            textures.rocketBase = textureLoader.load(
                "assets/Rocketship_baseColor.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Rocketship_baseColor.png");
                }
            );

            // Asteroid textures
            textures.asteroidColor = textureLoader.load(
                "assets/Asteroid2b_Color_1K.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Asteroid2b_Color_1K.png");
                }
            );

            textures.asteroidNormal = textureLoader.load(
                "assets/Asteroid2b_NormalGL_1K.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Asteroid2b_NormalGL_1K.png");
                }
            );

            // Galaxy texture removed - using simple purple background instead
        }

        function computeCameraBasis() {
            camera.getWorldDirection(tmpDir);
            camForward.set(tmpDir.x, 0, tmpDir.z).normalize();
            camRight.crossVectors(camForward, worldUp).normalize();
        }

        function createGalaxyTexture() {
            // Create a canvas for the galaxy texture
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Base dark purple
            ctx.fillStyle = '#1a0a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Create galaxy center (bright core)
            const centerX = canvas.width * 0.5;
            const centerY = canvas.height * 0.5;
            
            // Radial gradient for galaxy core
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.width * 0.4);
            gradient.addColorStop(0, '#8e24aa'); // Bright purple center
            gradient.addColorStop(0.3, '#6a1b9a'); // Medium purple
            gradient.addColorStop(0.6, '#4a148c'); // Dark purple
            gradient.addColorStop(1, '#1a0a2e'); // Very dark purple edge
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some spiral arms (simple diagonal gradients)
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const armGradient = ctx.createLinearGradient(
                    centerX, centerY,
                    centerX + Math.cos(angle) * canvas.width * 0.6,
                    centerY + Math.sin(angle) * canvas.height * 0.6
                );
                armGradient.addColorStop(0, 'rgba(142, 36, 170, 0.3)');
                armGradient.addColorStop(0.5, 'rgba(106, 27, 154, 0.2)');
                armGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = armGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Add stars (random white dots)
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2;
                const brightness = Math.random();
                
                ctx.globalAlpha = brightness * 0.8;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            
            // Make texture seamless by copying edge pixels
            // Get image data to manipulate pixels
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            
            // Copy rightmost column to leftmost column to ensure seamless wrap
            for (let y = 0; y < canvas.height; y++) {
                const leftIdx = (y * canvas.width + 0) * 4;
                const rightIdx = (y * canvas.width + (canvas.width - 1)) * 4;
                
                // Copy RGB from right edge to left edge
                pixels[leftIdx] = pixels[rightIdx];
                pixels[leftIdx + 1] = pixels[rightIdx + 1];
                pixels[leftIdx + 2] = pixels[rightIdx + 2];
                pixels[leftIdx + 3] = pixels[rightIdx + 3];
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            return texture;
        }

        function createSky() {
            // Increase segments for smoother sphere (reduces visible seams)
            const skyGeo = new THREE.SphereGeometry(120, 64, 64);
            const galaxyTexture = createGalaxyTexture();
            const skyMat = new THREE.MeshBasicMaterial({
                map: galaxyTexture,
                side: THREE.BackSide
            });
            
            skySphere = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skySphere);
        }

        // ------------------------------------------------------------
        // Black holes (no floor - holes float in space)
        // ------------------------------------------------------------
        function createInfiniteFloor() {
            // No floor tiles or grid - just initialize hole meshes
            floorGroup = null;
            floorTiles = [];
            holeMeshes = [];

            // Pre-allocate hole meshes for black holes (more than before since we're not limited by tiles)
            // Create enough for visible holes in a larger area
            const maxHoles = 20; // Enough for multiple tiles worth of holes
            for (let i = 0; i < maxHoles; i++) {
                // Create black hole as a dark circle with depth effect
                const hg = new THREE.CircleGeometry(1, 32);
                const hm = new THREE.MeshBasicMaterial({
                    color: 0x000000, // Pure black
                    transparent: true,
                    opacity: 0.95
                });
                const hmesh = new THREE.Mesh(hg, hm);
                hmesh.rotation.x = -Math.PI / 2;
                hmesh.position.y = 0.01;
                hmesh.visible = false;
                scene.add(hmesh);
                holeMeshes.push(hmesh);
            }
        }

        // Simple seeded random number generator for consistent randomness
        function seededRandom(seed) {
            // Simple LCG (Linear Congruential Generator)
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }

        function generateHolesForTile(tileX, tileZ) {
            // Create a deterministic seed from tile coordinates
            let seed = (tileX * 73856093) ^ (tileZ * 19349663);
            seed = (seed >>> 0); // Ensure positive integer
            
            // 0-2 holes per tile, deterministic based on tile position
            const r = seededRandom(seed);
            const holeCount = (r < 0.35) ? 0 : (r < 0.75 ? 1 : 2);

            const results = [];
            const margin = 5; // keep away from edges
            const usable = tileSize * 0.5 - margin;

            for (let i = 0; i < holeCount; i++) {
                // Generate new seed for each hole
                seed = (seed * 73856093) ^ (i * 19349663);
                seed = (seed >>> 0);
                
                const rx = seededRandom(seed);
                seed = (seed * 73856093) ^ ((i + 1) * 19349663);
                seed = (seed >>> 0);
                
                const rz = seededRandom(seed);
                seed = (seed * 73856093) ^ ((i + 2) * 19349663);
                seed = (seed >>> 0);

                // local offsets within tile
                const localX = THREE.MathUtils.lerp(-usable, usable, rx);
                const localZ = THREE.MathUtils.lerp(-usable, usable, rz);

                const sizeR = seededRandom(seed);
                const halfSize = THREE.MathUtils.lerp(1.6, 3.0, sizeR);

                results.push({ localX, localZ, halfSize });
            }

            return results;
        }

        function updateInfiniteFloorAndHoles() {
            if (!player) return;

            const cx = Math.floor(player.position.x / tileSize);
            const cz = Math.floor(player.position.z / tileSize);

            holes = []; // rebuild visible hole list each frame

            // Generate holes for visible tiles around player (3x3 grid)
            let holeMeshIndex = 0;

            for (let ox = -tileRadius; ox <= tileRadius; ox++) {
                for (let oz = -tileRadius; oz <= tileRadius; oz++) {
                    const tileX = cx + ox;
                    const tileZ = cz + oz;

                    // Generate holes for this tile
                    const tileHoles = generateHolesForTile(tileX, tileZ);

                    // Place visual holes + push collision holes
                    for (let i = 0; i < tileHoles.length; i++) {
                        const h = tileHoles[i];

                        // Calculate world position
                        const worldX = tileX * tileSize + h.localX;
                        const worldZ = tileZ * tileSize + h.localZ;

                        holes.push({ x: worldX, z: worldZ, halfSize: h.halfSize });

                        // Update visual black hole
                        const mesh = holeMeshes[holeMeshIndex++];
                        if (mesh) {
                            mesh.visible = true;
                            mesh.position.x = worldX;
                            mesh.position.z = worldZ;
                            mesh.position.y = 0.01;
                            // Scale to match collision radius: CircleGeometry(1) scaled by halfSize gives radius = halfSize
                            mesh.scale.set(h.halfSize, h.halfSize, 1);
                        }
                    }
                }
            }

            // Hide unused hole meshes
            for (let i = holeMeshIndex; i < holeMeshes.length; i++) {
                holeMeshes[i].visible = false;
            }
        }

        // ------------------------------------------------------------
        // Camera follow
        // ------------------------------------------------------------
        function updateCameraFollow(delta) {
            if (!player) return;

            cameraTargetPos.set(
                player.position.x + cameraOffset.x,
                cameraOffset.y,
                player.position.z + cameraOffset.z
            );

            if (delta > 0) {
                const alpha = 1 - Math.pow(0.001, delta);
                camera.position.lerp(cameraTargetPos, alpha);
            } else {
                camera.position.copy(cameraTargetPos);
            }

            cameraLookAtPos.set(player.position.x, 0, player.position.z);
            camera.lookAt(cameraLookAtPos);

            computeCameraBasis();
        }

        function updateSkyFollow() {
            if (!player || !skySphere) return;
            
            // Make the sky sphere follow the player's X and Z position
            // Keep Y at 0 since it's a sphere centered around the player
            skySphere.position.x = player.position.x;
            skySphere.position.z = player.position.z;
            skySphere.position.y = 0;
        }

        // ------------------------------------------------------------
        // Mode switching
        // ------------------------------------------------------------
        function setMode(prototype) {
            isPrototypeMode = prototype;
            btnPrototype.classList.toggle("active", prototype);
            btnFull.classList.toggle("active", !prototype);

            resetGameState();
            clearDynamicObjects();

            if (isPrototypeMode) {
                createPrototypePlayer();
                statusMessage.textContent = "Prototype mode: primitive geometries only.";
            } else {
                createFullPlayer();
                statusMessage.textContent = "Full mode: using loaded objected and textures.";
            }

            // Create baseline meteors and enemies
            ensureMeteors(baseMeteorCount);
            ensureEnemies(0);

            updateAIStatus();
            updateCameraFollow(0);
        }

        function resetGameState() {
            isGameOver = false;
            isFalling = false;
            score = 0;
            lastTime = 0;
            gameStartTime = 0; // Reset game start time

            scoreDisplay.textContent = "Score: 0.0";
            statusMessage.textContent = "";

            // Reset player velocity tracking
            if (player) {
                lastPlayerX = player.position.x;
                lastPlayerZ = player.position.z;
            }
            playerVelocityX = 0;
            playerVelocityZ = 0;
            
            // Reset enemy count tracking
            maxRequestedEnemyCount = 0;

            computerAI.reset();
        }

        function clearDynamicObjects() {
            if (player) {
                scene.remove(player);
                player = null;
            }
            
            if (rocketExhaust) {
                scene.remove(rocketExhaust);
                rocketExhaust = null;
            }

            meteors.forEach(m => scene.remove(m));
            meteorShadows.forEach(s => scene.remove(s));
            meteors = [];
            meteorShadows = [];
            meteorAnimations = []; // Reset collision animations
            
            // Reset debris (hide all pieces)
            debrisPool.forEach(piece => {
                piece.visible = false;
            });
            activeDebris = [];

            enemies.forEach(e => scene.remove(e));
            enemies = [];
            activeEnemyCount = 0;
        }

        // ------------------------------------------------------------
        // Player
        // ------------------------------------------------------------
        function createPrototypePlayer() {
            const playerGeo = new THREE.BoxGeometry(1.5, 1, 2);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.set(0, 1, 0);
            player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
            scene.add(player);
            
            // Initialize player position tracking for velocity calculation
            lastPlayerX = player.position.x;
            lastPlayerZ = player.position.z;
            playerVelocityX = 0;
            playerVelocityZ = 0;
        }

        function createFullPlayer() {
            // Try OBJ/MTL loader first (rocket ship)
            if (rocketShipTemplate) {
                // Already loaded once – just clone
                player = rocketShipTemplate.clone();
                applyRocketMaterials(player);
                player.scale.set(1.5, 1.5, 1.5);
                player.position.set(0, 1, 0);
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
                
                // Create rocket exhaust particles
                if (!rocketExhaust) {
                    rocketExhaust = createRocketExhaust();
                    scene.add(rocketExhaust);
                }
                
                lastPlayerX = player.position.x;
                lastPlayerZ = player.position.z;
                playerVelocityX = 0;
                playerVelocityZ = 0;
                updateCameraFollow(0);
            } else if (mtlLoader && objLoader) {
                // Load rocket from OBJ/MTL once
                const fallbackPlayer = createFallbackFullPlayer();
                player = fallbackPlayer;
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
                
                mtlLoader.load(
                    "cartoon_rocket_ship.mtl",
                    function (materials) {
                        materials.preload();
                        objLoader.setMaterials(materials);
                        objLoader.load(
                            "cartoon_rocket_ship.obj",
                            function (obj) {
                                rocketShipTemplate = obj;
                                if (player) scene.remove(player);

                                player = rocketShipTemplate.clone();
                                applyRocketMaterials(player);
                                player.scale.set(1.5, 1.5, 1.5);
                                player.position.set(0, 1, 0);
                                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                                scene.add(player);
                                
                                // Create rocket exhaust particles
                                if (!rocketExhaust) {
                                    rocketExhaust = createRocketExhaust();
                                    scene.add(rocketExhaust);
                                }
                                
                                lastPlayerX = player.position.x;
                                lastPlayerZ = player.position.z;
                                playerVelocityX = 0;
                                playerVelocityZ = 0;
                                updateCameraFollow(0);
                            },
                            undefined,
                            function (err) {
                                console.warn("Could not load rocket ship OBJ, using fallback player.", err);
                            }
                        );
                    },
                    undefined,
                    function (err) {
                        console.warn("Could not load rocket ship MTL, using fallback player.", err);
                    }
                );
            } else if (gltfLoader) {
                // Fallback to GLTF loader if available
                const fallback = createFallbackFullPlayer();
                player = fallback;
                scene.add(player);

                gltfLoader.load(
                    "assets/models/spaceship.glb",
                    function (gltf) {
                        if (player) scene.remove(player);
                        player = gltf.scene;
                        player.traverse(obj => {
                            if (obj.isMesh) {
                                obj.castShadow = true;
                                obj.receiveShadow = true;
                            }
                        });
                        player.scale.set(1.8, 1.8, 1.8);
                        player.position.set(0, 1, 0);
                        scene.add(player);
                        
                        // Create rocket exhaust particles
                        if (!rocketExhaust) {
                            rocketExhaust = createRocketExhaust();
                            scene.add(rocketExhaust);
                        }
                        
                        lastPlayerX = player.position.x;
                        lastPlayerZ = player.position.z;
                        playerVelocityX = 0;
                        playerVelocityZ = 0;
                        updateCameraFollow(0);
                    },
                    undefined,
                    function () {}
                );
            } else {
                // No loaders – use basic cylinder+cone
                const fallbackPlayer = createFallbackFullPlayer();
                player = fallbackPlayer;
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
                
                // Create rocket exhaust particles
                if (!rocketExhaust) {
                    rocketExhaust = createRocketExhaust();
                    scene.add(rocketExhaust);
                }
            }
        }

        function createFallbackFullPlayer() {
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.8, 2.2, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00bcd4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);

            const noseGeo = new THREE.ConeGeometry(0.5, 1.0, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.y = 1.5;

            const group = new THREE.Group();
            group.add(body);
            group.add(nose);
            group.position.set(0, 1, 0);
            return group;
        }

        function applyRocketMaterials(root) {
            root.traverse(obj => {
                if (!obj.isMesh) return;

                obj.castShadow = true;
                obj.receiveShadow = true;

                if (textures.rocketBase) {
                    obj.material = new THREE.MeshStandardMaterial({
                        map: textures.rocketBase,
                        metalness: 0.3,
                        roughness: 0.6
                    });
                } else if (obj.material) {
                    obj.material = obj.material.clone();
                }
            });
        }

        // ------------------------------------------------------------
        // Rocket Exhaust Particles
        // ------------------------------------------------------------
        function createRocketExhaust() {
            const particleCount = 150;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            // Initialize all particles as inactive
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = 0;
                positions[i * 3 + 1] = -1000; // Hide off-screen
                positions[i * 3 + 2] = 0;
                colors[i * 3] = 1; // R
                colors[i * 3 + 1] = 0.5; // G
                colors[i * 3 + 2] = 0; // B
                lifetimes[i] = 0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.userData = {
                positions: positions,
                colors: colors,
                lifetimes: lifetimes,
                velocities: new Array(particleCount).fill(null).map(() => new THREE.Vector3()),
                particleCount: particleCount
            };
            
            return particles;
        }

        function updateRocketExhaust(delta) {
            if (!rocketExhaust || !player) return;
            
            const userData = rocketExhaust.userData;
            const positions = userData.positions;
            const colors = userData.colors;
            const lifetimes = userData.lifetimes;
            const velocities = userData.velocities;
            
            // If player is falling into black hole, quickly fade out all particles and stop spawning
            if (isFalling) {
                // Quickly expire all existing particles
                for (let i = 0; i < userData.particleCount; i++) {
                    if (lifetimes[i] > 0) {
                        // Accelerate particle expiration
                        lifetimes[i] -= delta * 5; // 5x faster fade
                        if (lifetimes[i] <= 0) {
                            lifetimes[i] = 0;
                            // Hide particle
                            positions[i * 3 + 1] = -1000;
                        } else {
                            // Fade out existing particles quickly
                            const lifeRatio = lifetimes[i] / 0.5;
                            colors[i * 3] = 1.0 * lifeRatio;
                            colors[i * 3 + 1] = (0.3 + lifeRatio * 0.4) * lifeRatio;
                            colors[i * 3 + 2] = 0;
                        }
                    } else {
                        // Hide any inactive particles
                        positions[i * 3 + 1] = -1000;
                    }
                }
                
                // Update geometry attributes
                rocketExhaust.geometry.attributes.position.needsUpdate = true;
                rocketExhaust.geometry.attributes.color.needsUpdate = true;
                return; // Don't spawn new particles or update normally
            }
            
            // Calculate exhaust position at the center of the rocket (in world space)
            // Get rocket's forward direction (where the tip points)
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyQuaternion(player.quaternion);
            
            // Get rocket's right direction for spread
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(player.quaternion);
            
            // Get rocket's up direction
            const up = new THREE.Vector3(0, 1, 0);
            up.applyQuaternion(player.quaternion);
            
            // Calculate exhaust position at the center of the rocket
            // Particles spawn at the rocket's center position
            const exhaustWorldPos = new THREE.Vector3(
                player.position.x,
                player.position.y,
                player.position.z
            );
            
            // Update existing particles and spawn new ones
            for (let i = 0; i < userData.particleCount; i++) {
                if (lifetimes[i] > 0) {
                    // Update existing particle
                    lifetimes[i] -= delta;
                    
                    if (lifetimes[i] <= 0) {
                        // Particle expired, hide it
                        positions[i * 3 + 1] = -1000;
                        continue;
                    }
                    
                    // Update position (move backward/down relative to rocket)
                    positions[i * 3] += velocities[i].x * delta;
                    positions[i * 3 + 1] += velocities[i].y * delta;
                    positions[i * 3 + 2] += velocities[i].z * delta;
                    
                    // Fade out as particle ages
                    const lifeRatio = lifetimes[i] / 0.5; // 0.5 second lifetime
                    const opacity = lifeRatio;
                    
                    // Color gradient: bright orange/yellow at start, red at end
                    colors[i * 3] = 1.0; // R - always red/orange
                    colors[i * 3 + 1] = 0.3 + lifeRatio * 0.4; // G - more yellow when young
                    colors[i * 3 + 2] = 0; // B
                } else {
                    // Spawn new particle (with some randomness)
                    if (Math.random() < 0.15) { // 15% chance per frame
                        lifetimes[i] = 0.3 + Math.random() * 0.4; // 0.3-0.7 second lifetime
                        
                        // Start at exhaust position
                        positions[i * 3] = exhaustWorldPos.x + (Math.random() - 0.5) * 0.2;
                        positions[i * 3 + 1] = exhaustWorldPos.y;
                        positions[i * 3 + 2] = exhaustWorldPos.z + (Math.random() - 0.5) * 0.2;
                        
                        // Determine if rocket is moving
                        const isMoving = Math.abs(playerVelocityX) > 0.1 || Math.abs(playerVelocityZ) > 0.1;
                        
                        // Down direction: straight down in world space if not moving, or relative to rocket angle if moving
                        let downVel;
                        if (isMoving) {
                            // Use rocket's local down direction (negative of up vector)
                            downVel = up.clone().multiplyScalar(-(3 + Math.random() * 3)); // Down relative to rocket's angle
                            
                            // Add some backward component when moving
                            const speed = 2 + Math.random() * 3;
                            const backwardVel = forward.clone().multiplyScalar(-speed); // Negative = backward
                            const spreadVel = right.clone().multiplyScalar((Math.random() - 0.5) * 1.5); // Horizontal spread
                            velocities[i].copy(backwardVel).add(downVel).add(spreadVel);
                        } else {
                            // When not moving, go straight down in world space (no backward component)
                            downVel = new THREE.Vector3(0, -(3 + Math.random() * 3), 0); // Straight down in world space
                            const spreadVel = right.clone().multiplyScalar((Math.random() - 0.5) * 1.0); // Small horizontal spread
                            velocities[i].copy(downVel).add(spreadVel);
                        }
                        
                        // Initial color (bright orange/yellow)
                        colors[i * 3] = 1.0;
                        colors[i * 3 + 1] = 0.6 + Math.random() * 0.3;
                        colors[i * 3 + 2] = 0;
                    }
                }
            }
            
            // Update geometry attributes
            rocketExhaust.geometry.attributes.position.needsUpdate = true;
            rocketExhaust.geometry.attributes.color.needsUpdate = true;
        }

        function applyAsteroidMaterials(root) {
            root.traverse(obj => {
                if (!obj.isMesh) return;

                obj.castShadow = true;
                obj.receiveShadow = true;

                obj.material = new THREE.MeshStandardMaterial({
                    map: textures.asteroidColor || null,
                    normalMap: textures.asteroidNormal || null,
                    metalness: 0.1,
                    roughness: 0.9
                });
            });
        }

        // ------------------------------------------------------------
        // Meteors (pooled)
        // ------------------------------------------------------------
        function ensureMeteors(targetCount) {
            const count = Math.min(targetCount, maxMeteorCount);
            
            // Ensure animation array is large enough
            while (meteorAnimations.length < count) {
                meteorAnimations.push(null);
            }

            const shadowGeo = new THREE.CircleGeometry(0.9, 16);

            // Prototype meteors use spheres
            if (isPrototypeMode) {
                const meteorGeo = new THREE.SphereGeometry(0.8, 16, 16);

                while (meteors.length < count) {
                    // Create a new material instance for each meteor to avoid shared state
                    const meteorMat = new THREE.MeshStandardMaterial({ color: 0xff6347 });
                    const mesh = new THREE.Mesh(meteorGeo, meteorMat);
                    resetMeteorNearPlayer(mesh, true);
                    scene.add(mesh);
                    meteors.push(mesh);

                    const shadowMat = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.35
                    });
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.rotation.x = -Math.PI / 2;
                    shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                    scene.add(shadow);
                    meteorShadows.push(shadow);
                }
                return;
            }

            // Full mode: prefer OBJ asteroid if available
            function spawnMeteorFromPrototype(prototype) {
                const mesh = prototype.clone();
                mesh.traverse(obj => {
                    if (obj.isMesh) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                });
                
                mesh.rotation.x = Math.random() * Math.PI * 2;
                mesh.rotation.y = Math.random() * Math.PI * 2;
                mesh.rotation.z = Math.random() * Math.PI * 2;

                const scale = Math.random() * 0.2 + 0.8;
                mesh.scale.set(scale, scale, scale);
                
                resetMeteorNearPlayer(mesh, true);
                scene.add(mesh);
                meteors.push(mesh);

                const shadowMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.35
                });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                scene.add(shadow);
                meteorShadows.push(shadow);
            }

            // If we already have a template, just clone until count reached
            if (asteroidTemplate) {
                while (meteors.length < count) {
                    spawnMeteorFromPrototype(asteroidTemplate);
                }
                return;
            }

            // Try loading asteroid once, then backfill
            if (mtlLoader && objLoader) {
                mtlLoader.load(
                    "Asteroid_2b.mtl",
                    function (materials) {
                        materials.preload();
                        objLoader.setMaterials(materials);
                        objLoader.load(
                            "Asteroid_2b.obj",
                            function (obj) {
                                asteroidTemplate = obj;
                                applyAsteroidMaterials(asteroidTemplate);
                                while (meteors.length < count) {
                                    spawnMeteorFromPrototype(asteroidTemplate);
                                }
                            },
                            undefined,
                            function () {
                                createFallbackRockMeteors(count);
                            }
                        );
                    },
                    undefined,
                    function () {
                        createFallbackRockMeteors(count);
                    }
                );
            } else {
                createFallbackRockMeteors(count);
            }

            function createFallbackRockMeteors(n) {
                const meteorGeo = new THREE.SphereGeometry(0.8, 24, 24);

                while (meteors.length < n) {
                    const mat = new THREE.MeshStandardMaterial({
                        map: textures.asteroidColor || null,
                        normalMap: textures.asteroidNormal || null,
                        metalness: 0.1,
                        roughness: 0.9
                    });

                    const mesh = new THREE.Mesh(meteorGeo, mat);
                    resetMeteorNearPlayer(mesh, true);
                    scene.add(mesh);
                    meteors.push(mesh);

                    const shadowMat = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.35
                    });
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.rotation.x = -Math.PI / 2;
                    shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                    scene.add(shadow);
                    meteorShadows.push(shadow);
                }
            }
        }

        function resetMeteorNearPlayer(meteor, randomHeight) {
            const centerX = player ? player.position.x : 0;
            const centerZ = player ? player.position.z : 0;

            const angle = Math.random() * Math.PI * 2;
            const dist = THREE.MathUtils.randFloat(meteorSpawnRadiusMin, meteorSpawnRadiusMax);

            meteor.position.x = centerX + Math.cos(angle) * dist;
            meteor.position.z = centerZ + Math.sin(angle) * dist;
            meteor.position.y = randomHeight
                ? THREE.MathUtils.randFloat(6, 24)
                : THREE.MathUtils.randFloat(14, 26);
        }

        // ------------------------------------------------------------
        // Enemies (pooled chasers)
        // ------------------------------------------------------------
        function ensureEnemies(targetCount) {
            // Prototype mode: spawn simple rectangle enemies (no alien models).
            if (isPrototypeMode) {
                const count = Math.min(targetCount, maxEnemyCount);

                // Create simple box enemies until we reach count
                const enemyGeo = new THREE.BoxGeometry(1.4, 1.2, 1.4);
                while (enemies.length < count) {
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffcc66 });
                    const e = new THREE.Mesh(enemyGeo, mat);
                    e.position.y = 0.6;
                    e.castShadow = true;
                    e.receiveShadow = true;
                    e.visible = true;
                    spawnEnemyNearPlayer(e);
                    scene.add(e);
                    enemies.push(e);
                }

                activeEnemyCount = Math.min(count, enemies.length);
                return;
            }
            const count = Math.min(targetCount, maxEnemyCount);
            
            // Track maximum requested count (for when model is loading)
            if (count > maxRequestedEnemyCount) {
                maxRequestedEnemyCount = count;
            }
            
            // Early return if we already have enough enemies
            // Make sure activeEnemyCount matches the actual enemy count
            if (enemies.length >= count) {
                // Only update activeEnemyCount if it's different to avoid unnecessary work
                if (activeEnemyCount !== count) {
                    activeEnemyCount = Math.min(count, enemies.length);
                }
                return;
            }

            // Full mode: prefer OBJ alien model if available
            function spawnEnemyFromPrototype(prototype) {
                const e = prototype.clone();
                e.traverse(obj => {
                    if (obj.isMesh) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                        obj.visible = true;
                    }
                });
                
                // Random rotation for variety
                e.rotation.y = Math.random() * Math.PI * 2;
                
                // Scale appropriately (3x size)
                e.scale.set(3.0, 3.0, 3.0);
                e.position.y = 0.6;
                e.visible = true;
                spawnEnemyNearPlayer(e);
                scene.add(e);
                enemies.push(e);
            }

            // If we already have a template, just clone until count reached
            if (alienTemplate) {
                while (enemies.length < count) {
                    spawnEnemyFromPrototype(alienTemplate);
                }
                activeEnemyCount = Math.min(count, enemies.length);
                return;
            }

            // Wait for alien model to load before creating enemies
            if (mtlLoader && objLoader && !alienTemplate && !alienTemplateLoading) {
                alienTemplateLoading = true; // Mark as loading to prevent multiple loads
                
                // Load the alien model first
                mtlLoader.load(
                    "cute_alien_character.mtl",
                    function (materials) {
                        materials.preload(); // This waits for textures to load
                        objLoader.setMaterials(materials);
                        objLoader.load(
                            "cute_alien_character.obj",
                            function (obj) {
                                alienTemplate = obj;
                                alienTemplateLoading = false; // Mark as loaded
                                
                                // Apply materials to template
                                alienTemplate.traverse(obj => {
                                    if (obj.isMesh) {
                                        obj.castShadow = true;
                                        obj.receiveShadow = true;
                                    }
                                });
                                
                                // Now that the model and textures are loaded, create enemies up to the maximum requested count
                                const targetCount = Math.min(maxRequestedEnemyCount, maxEnemyCount);
                                while (enemies.length < targetCount) {
                                    spawnEnemyFromPrototype(alienTemplate);
                                }
                                activeEnemyCount = Math.min(targetCount, enemies.length);
                            },
                            undefined,
                            function (err) {
                                alienTemplateLoading = false; // Reset on error
                                console.warn("Could not load cute_alien_character.obj.", err);
                            }
                        );
                    },
                    undefined,
                    function (err) {
                        alienTemplateLoading = false; // Reset on error
                        console.warn("Could not load cute_alien_character.mtl.", err);
                    }
                );
            } else if (!mtlLoader || !objLoader) {
                // If loaders aren't available, don't create enemies
                console.warn("Model loaders not available, cannot create alien enemies.");
            }
            // If already loading, enemies will be created when the model finishes loading
        }

        function spawnEnemyNearPlayer(enemy) {
            const centerX = player ? player.position.x : 0;
            const centerZ = player ? player.position.z : 0;

            const angle = Math.random() * Math.PI * 2;
            const dist = THREE.MathUtils.randFloat(enemySpawnRadiusMin, enemySpawnRadiusMax);

            enemy.position.x = centerX + Math.cos(angle) * dist;
            enemy.position.z = centerZ + Math.sin(angle) * dist;
        }

        // ------------------------------------------------------------
        // Input handling
        // ------------------------------------------------------------
        function setupInput() {
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);

            btnPrototype.addEventListener("click", () => setMode(true));
            btnFull.addEventListener("click", () => setMode(false));
            btnAI.addEventListener("click", toggleAI);

            if (chkHoleAvoid) {
                chkHoleAvoid.addEventListener("change", () => {
                    if (computerAI.setHoleAvoidanceEnabled) {
                        computerAI.setHoleAvoidanceEnabled(chkHoleAvoid.checked);
                    }
                });
            }
            if (chkThinkingTime) {
                chkThinkingTime.addEventListener("change", () => {
                    if (computerAI.setThinkingTimeEnabled) {
                        computerAI.setThinkingTimeEnabled(chkThinkingTime.checked);
                    }
                });
            }
            if (chkEnemyAvoid) {
                chkEnemyAvoid.addEventListener("change", () => {
                    if (computerAI.setEnemyAvoidanceEnabled) {
                        computerAI.setEnemyAvoidanceEnabled(chkEnemyAvoid.checked);
                    }
                });
            }

            const controlButtons = document.querySelectorAll("#controls button[data-dir]");
            controlButtons.forEach(btn => {
                const dir = btn.getAttribute("data-dir");

                function pressHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, true);
                }

                function releaseHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, false);
                }

                btn.addEventListener("mousedown", pressHandler);
                btn.addEventListener("mouseup", releaseHandler);
                btn.addEventListener("mouseleave", releaseHandler);

                btn.addEventListener("touchstart", pressHandler, { passive: false });
                btn.addEventListener("touchend", releaseHandler, { passive: false });
                btn.addEventListener("touchcancel", releaseHandler, { passive: false });
            });

            updateAIStatus();
        }

        function onKeyDown(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = true;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = true;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = true;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = true;

            if (e.key === "r" || e.key === "R") {
                setMode(isPrototypeMode);
            }

            if (e.key === "i" || e.key === "I") {
                useAI = !useAI;
                updateAIStatus();
            }

            if (e.key === "[" || e.key === "{") {
                aiLevel = Math.max(1, aiLevel - 1);
                updateAIStatus();
            }
            if (e.key === "]" || e.key === "}") {
                aiLevel = Math.min(10, aiLevel + 1);
                updateAIStatus();
            }
        }

        function onKeyUp(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = false;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = false;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = false;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = false;
        }

        function setMoveState(dir, value) {
            if (dir === "left") moveState.left = value;
            if (dir === "right") moveState.right = value;
            if (dir === "up") moveState.forward = value;
            if (dir === "down") moveState.backward = value;
        }

        function toggleAI() {
            useAI = !useAI;
            updateAIStatus();
        }

        function updateAIStatus() {
            btnAI.textContent = useAI ? "ON" : "OFF";
            btnAI.classList.toggle("active", useAI);

            const levelDesc = getLevelDescription(aiLevel);
            aiLevelDisplay.textContent = `AI Level: ${aiLevel} (${levelDesc})`;

            if (!isGameOver) {
                statusMessage.textContent = useAI
                    ? "AI ACTIVE - Press [ ] to adjust level, I to disable"
                    : "Manual control - Press I to enable AI";
                statusMessage.style.color = useAI ? "#4caf50" : "#ffcc66";
            }
        }

        function getLevelDescription(level) {
            if (level <= 3) return "Beginner";
            if (level <= 6) return "Intermediate";
            if (level <= 9) return "Advanced";
            return "Expert";
        }

        // ------------------------------------------------------------
        // Game loop
        // ------------------------------------------------------------
        function animate(timestamp) {
            requestAnimationFrame(animate);

            const t = timestamp * 0.001;
            const delta = lastTime ? t - lastTime : 0;
            lastTime = t;

            if (!player) {
                renderer.render(scene, camera);
                return;
            }

            // Track game start time (first frame after reset)
            if (gameStartTime === 0 && !isGameOver) {
                gameStartTime = t;
            }

            // Update floor + holes first so collision uses current holes
            updateInfiniteFloorAndHoles();

            if (!isGameOver) {
                const gameTime = gameStartTime > 0 ? t - gameStartTime : 0;
                updateDifficulty(gameTime);
                updatePlayer(delta);
                updateRocketExhaust(delta);
                updateCameraFollow(delta);
                updateSkyFollow();

                updateMeteors(delta);
                updateEnemies(delta);
                updateExplosionDebris(delta);

                checkCollisions();

                score += delta;
                scoreDisplay.textContent = "Score: " + score.toFixed(1);
            } else {
                // Keep visuals alive
                updatePlayer(delta); // handles falling animation
                updateRocketExhaust(delta);
                updateCameraFollow(delta);
                updateSkyFollow();
                updateMeteors(delta);
                updateEnemies(delta);
                updateExplosionDebris(delta);
            }

            renderer.render(scene, camera);
        }

        function updateDifficulty(liveTime) {
            const meteorTarget = Math.min(
                maxMeteorCount,
                baseMeteorCount + Math.floor(liveTime / 10) * 6
            );
            ensureMeteors(meteorTarget);

            let enemyTarget = 0;
            if (liveTime >= enemyStartTime) {
                enemyTarget = Math.min(
                    maxEnemyCount,
                    1 + Math.floor((liveTime - enemyStartTime) / 12)
                );
            }
            ensureEnemies(enemyTarget);
        }

        // ------------------------------------------------------------
        // Player update (keeps your falling logic)
        // ------------------------------------------------------------
        function updatePlayer(delta) {
            if (!player) return;

            const playerRadius = 0.9;

            // Trigger falling when fully inside a hole
            if (!isGameOver && isFullyInHole(player.position.x, player.position.z, playerRadius)) {
                isGameOver = true;
                
                // Prototype mode: no black hole spinning/shrinking animation (instant game over message).
                if (isPrototypeMode) {
                    isFalling = false;
                    statusMessage.style.color = "#ffcc66";
                    statusMessage.textContent =
                        "Game over! Final score " + score.toFixed(1) +
                        ". You were consumed by a black hole! Press R or switch mode to restart.";
                    return;
                }

                isFalling = true;
                blackHoleAnimationStartTime = Date.now() / 1000;
                
                // Store initial state
                initialPlayerScale.copy(player.scale);
                
                // Find the black hole the player fell into
                const hole = findHoleAtPosition(player.position.x, player.position.z);
                if (hole) {
                    blackHoleTargetPos.set(hole.x, 0.01, hole.z);
                } else {
                    blackHoleTargetPos.set(player.position.x, 0.01, player.position.z);
                }
                
                statusMessage.style.color = "#ffcc66";
            }

            if (isGameOver) {
                if (isFalling) {
                    const currentTime = Date.now() / 1000;
                    const elapsed = currentTime - blackHoleAnimationStartTime;
                    const progress = Math.min(elapsed / blackHoleAnimationDuration, 1.0);
                    
                    // Spinning animation - rotate around all axes (faster as it gets pulled in)
                    const spinMultiplier = 1.0 + progress * 2.0; // Spin faster as it shrinks
                    player.rotation.x += blackHoleSpinSpeed * Math.PI * 2 * delta * 0.3 * spinMultiplier;
                    player.rotation.y += blackHoleSpinSpeed * Math.PI * 2 * delta * spinMultiplier;
                    player.rotation.z += blackHoleSpinSpeed * Math.PI * 2 * delta * 0.5 * spinMultiplier;
                    
                    // Shrinking animation - scale down to 0
                    // Use easing for more dramatic effect (ease-in cubic)
                    const easedProgress = 1.0 - Math.pow(1.0 - progress, 3);
                    const easedScale = 1.0 - easedProgress;
                    player.scale.set(
                        initialPlayerScale.x * easedScale,
                        initialPlayerScale.y * easedScale,
                        initialPlayerScale.z * easedScale
                    );
                    
                    // Move towards black hole center (stronger pull as it gets closer)
                    const pullStrength = easedProgress * 0.8;
                    const targetX = THREE.MathUtils.lerp(player.position.x, blackHoleTargetPos.x, pullStrength * delta * 3);
                    const targetZ = THREE.MathUtils.lerp(player.position.z, blackHoleTargetPos.z, pullStrength * delta * 3);
                    player.position.x = targetX;
                    player.position.z = targetZ;
                    
                    // Slight downward movement (faster as it shrinks)
                    player.position.y -= 3 * delta * easedProgress;
                    
                    if (progress >= 1.0 && !statusMessage.textContent.includes("Game over")) {
                        statusMessage.textContent =
                            "Game over! Final score " + score.toFixed(1) +
                            ". You were consumed by a black hole! Press R or switch mode to restart.";
                    }
                }
                return;
            }

            // Input in screen space
            let ix = 0;
            let iz = 0;

            if (useAI && computerAI && computerAI.suggestMove) {
                const speedBoost = score * 0.15;
                const meteorFallSpeed = baseMeteorSpeed + speedBoost;

                const meteorData = meteors.map(m => ({
                    position: { x: m.position.x, y: m.position.y, z: m.position.z },
                    velocity: { x: 0, y: -meteorFallSpeed, z: 0 }
                }));

                const enemyData = enemies.slice(0, activeEnemyCount).map(e => ({
                    position: { x: e.position.x, y: e.position.y, z: e.position.z }
                }));

                const move = computerAI.suggestMove(
                    meteorData,
                    { x: player.position.x, y: player.position.y, z: player.position.z },
                    score,
                    aiLevel,
                    enemyData,
                    holes
                );

                const worldDx = move.dx || 0;
                const worldDz = move.dz || 0;

                ix = worldDx * camRight.x + worldDz * camRight.z;
                iz = worldDx * camForward.x + worldDz * camForward.z;
            } else {
                if (moveState.left)  ix -= 1;
                if (moveState.right) ix += 1;
                if (moveState.forward)  iz += 1;
                if (moveState.backward) iz -= 1;
            }

            // If no input, return to neutral tilt and exit
            if (ix === 0 && iz === 0) {
                player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, 0, 0.15);
                player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.15);
                return;
            }

            const len = Math.sqrt(ix * ix + iz * iz);
            ix /= len;
            iz /= len;

            const worldMove = new THREE.Vector3();
            worldMove.copy(camRight).multiplyScalar(ix);
            worldMove.addScaledVector(camForward, iz);

            const dist = playerSpeed * delta;
            player.position.x += worldMove.x * dist;
            player.position.z += worldMove.z * dist;
            
            // Calculate player velocity (for meteor drift)
            if (delta > 0) {
                playerVelocityX = (player.position.x - lastPlayerX) / delta;
                playerVelocityZ = (player.position.z - lastPlayerZ) / delta;
                lastPlayerX = player.position.x;
                lastPlayerZ = player.position.z;
            }

            // Tilt in the direction of movement (only when actually moving)
            const maxTilt = 0.35;
            const normalizedMove = new THREE.Vector3(worldMove.x, 0, worldMove.z).normalize();
            // Tilt forward/backward based on Z movement, left/right based on X movement
            // Forward (Z+) → tilt forward (rotation.x+), Backward (Z-) → tilt backward (rotation.x-)
            // Left (X-) → tilt left (rotation.z+), Right (X+) → tilt right (rotation.z-)
            const targetTiltX = THREE.MathUtils.clamp(normalizedMove.z * maxTilt, -maxTilt, maxTilt);
            const targetTiltZ = THREE.MathUtils.clamp(-normalizedMove.x * maxTilt, -maxTilt, maxTilt);
            
            player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, targetTiltX, 0.15);
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, targetTiltZ, 0.15);
        }

        // ------------------------------------------------------------
        // Meteors update + shadows
        // ------------------------------------------------------------
        function updateMeteors(delta) {
            const speedBoost = score * 0.15;
            const fallSpeed = baseMeteorSpeed + speedBoost;
            const currentTime = Date.now() / 1000;

            for (let i = 0; i < meteors.length; i++) {
                const m = meteors[i];
                const s = meteorShadows[i];
                
                // Prototype mode: keep meteor + shadow logic simple and deterministic
                if (isPrototypeMode) {
                    // Clear any leftover animation state (e.g., after switching from full mode)
                    if (meteorAnimations[i]) meteorAnimations[i] = null;

                    // Ensure meteor is visible and fully opaque
                    m.visible = true;
                    if (m.material && m.material.opacity !== undefined) {
                        m.material.opacity = 1.0;
                        m.material.transparent = false;
                    }

                    // Fall + spin
                    m.position.y -= fallSpeed * delta;
                    m.rotation.x += 0.8 * delta;
                    m.rotation.y += 0.5 * delta;

                    // "Ground" collision => respawn (no crumble/debris)
                    if (m.position.y <= 0.1) {
                        resetMeteorNearPlayer(m, true);
                    }

                    // Shadow: always visible, tied to meteor x/z, scaled by height
                    if (s) {
                        s.visible = true;
                        s.position.set(m.position.x, 0.02, m.position.z);
                        const t = THREE.MathUtils.clamp((m.position.y - 2) / 18, 0, 1);
                        const scale = THREE.MathUtils.lerp(1.5, 0.4, t);
                        s.scale.set(scale, scale, 1);
                        s.material.opacity = THREE.MathUtils.lerp(0.55, 0.15, t);
                    }
                    continue;
                }
                
                // Check if this meteor is currently animating
                const animData = meteorAnimations[i];
                
                if (animData && animData.isAnimating) {
                    // Handle collision animation
                    const elapsed = currentTime - animData.startTime;
                    const progress = Math.min(elapsed / meteorAnimationDuration, 1.0);
                    
                    // If meteor is hidden, debris explosion is active - skip old animation
                    if (!m.visible) {
                        // Just wait for animation duration, then reset
                        if (progress >= 1.0) {
                            // Animation complete - reset meteor (debris animation handles visual)
                            const originalScale = animData.originalScale || new THREE.Vector3(1, 1, 1);
                            meteorAnimations[i] = null;
                            resetMeteorNearPlayer(m, false);
                            // Restore original scale and make visible again
                            m.scale.copy(originalScale);
                            m.visible = true;
                            if (m.traverse) {
                                m.traverse(obj => {
                                    if (obj.isMesh && obj.material) {
                                        if (Array.isArray(obj.material)) {
                                            obj.material.forEach(mat => {
                                                mat.opacity = 1.0;
                                            });
                                        } else {
                                            obj.material.opacity = 1.0;
                                        }
                                    }
                                });
                            }
                            // Update shadow position and visibility when reset
                            if (s) {
                                s.visible = true;
                                s.position.x = m.position.x;
                                s.position.z = m.position.z;
                                // Reset shadow scale and opacity for new position
                                const t = THREE.MathUtils.clamp((m.position.y - 2) / 18, 0, 1);
                                const scale = THREE.MathUtils.lerp(1.5, 0.4, t);
                                s.scale.set(scale, scale, 1);
                                s.material.opacity = THREE.MathUtils.lerp(0.55, 0.15, t);
                            }
                        }
                        // Skip the old animation code when debris is active - update shadow and continue to next meteor
                        if (s) s.visible = false;
                        continue;
                    }
                    
                    if (progress < 1.0) {
                        // Animation in progress (old animation - only if meteor is still visible)
                        // Scale up then down (explosion effect)
                        const scaleProgress = progress < 0.3 
                            ? progress / 0.3  // Scale up in first 30%
                            : 1.0 - ((progress - 0.3) / 0.7); // Scale down in remaining 70%
                        
                        const baseScale = animData.initialScale || 1.0;
                        const explosionScale = baseScale * (1.0 + scaleProgress * 1.5); // Scale up to 2.5x
                        m.scale.set(explosionScale, explosionScale, explosionScale);
                        
                        // Rapid rotation during explosion
                        m.rotation.x += 12 * delta;
                        m.rotation.y += 12 * delta;
                        m.rotation.z += 12 * delta;
                        
                        // Fade out
                        if (m.material && m.material.opacity !== undefined) {
                            m.material.opacity = 1.0 - progress;
                            m.material.transparent = true;
                        } else if (m.traverse) {
                            m.traverse(obj => {
                                if (obj.isMesh && obj.material) {
                                    if (Array.isArray(obj.material)) {
                                        obj.material.forEach(mat => {
                                            mat.opacity = 1.0 - progress;
                                            mat.transparent = true;
                                        });
                                    } else {
                                        obj.material.opacity = 1.0 - progress;
                                        obj.material.transparent = true;
                                    }
                                }
                            });
                        }
                        
                        // Keep at ground level
                        m.position.y = 0.1;
                        
                        // Hide shadow during animation
                        if (s) s.visible = false;
                    } else {
                        // Animation complete - reset meteor (debris animation handles visual)
                        const originalScale = animData.originalScale || new THREE.Vector3(1, 1, 1);
                        meteorAnimations[i] = null;
                        resetMeteorNearPlayer(m, false);
                        // Restore original scale and make visible again
                        m.scale.copy(originalScale);
                        m.visible = true;
                        if (m.traverse) {
                            m.traverse(obj => {
                                if (obj.isMesh && obj.material) {
                                    if (Array.isArray(obj.material)) {
                                        obj.material.forEach(mat => {
                                            mat.opacity = 1.0;
                                        });
                                    } else {
                                        obj.material.opacity = 1.0;
                                    }
                                }
                            });
                        }
                        // Update shadow position and visibility
                        if (s) {
                            s.visible = true;
                            s.position.x = m.position.x;
                            s.position.z = m.position.z;
                            // Reset shadow scale and opacity for new position
                            const t = THREE.MathUtils.clamp((m.position.y - 2) / 18, 0, 1);
                            const scale = THREE.MathUtils.lerp(1.5, 0.4, t);
                            s.scale.set(scale, scale, 1);
                            s.material.opacity = THREE.MathUtils.lerp(0.55, 0.15, t);
                        }
                    }
                } else {
                    // Normal falling behavior
                    m.position.y -= fallSpeed * delta;
                    m.rotation.x += 0.8 * delta;
                    m.rotation.y += 0.5 * delta;

                    // Check for ground collision
                    if (m.position.y <= 0.1) {
                        // Prototype mode: no crumble/debris animation; just respawn the meteor.
                        if (isPrototypeMode) {
                            resetMeteorNearPlayer(m, true);
                            m.visible = true;
                            if (s) {
                                s.visible = true;
                                s.position.set(m.position.x, 0.02, m.position.z);
                            }
                            meteorAnimations[i] = null;
                            continue;
                        }

                        // Get meteor material for debris (before hiding)
                        let meteorMat = null;
                        if (m.material) {
                            meteorMat = m.material;
                        } else if (m.traverse) {
                            m.traverse(obj => {
                                if (obj.isMesh && obj.material && !meteorMat) {
                                    meteorMat = Array.isArray(obj.material) ? obj.material[0] : obj.material;
                                }
                            });
                        }
                        
                        // Hide meteor immediately and trigger debris explosion
                        m.visible = false;
                        if (s) s.visible = false;
                        
                        // Create debris explosion at collision point
                        activateDebrisExplosion(m.position.clone(), meteorMat);
                        
                        // Reset meteor after a short delay (debris will handle visual)
                        meteorAnimations[i] = {
                            isAnimating: true,
                            startTime: currentTime,
                            initialScale: m.scale.x,
                            originalScale: new THREE.Vector3().copy(m.scale)
                        };
                        m.position.y = 0.1; // Snap to ground
                    }

                    // Update shadow
                    if (s) {
                        s.visible = m.visible; // Ensure shadow visibility matches meteor visibility
                        s.position.x = m.position.x;
                        s.position.z = m.position.z;

                        const t = THREE.MathUtils.clamp((m.position.y - 2) / 18, 0, 1);
                        const scale = THREE.MathUtils.lerp(1.5, 0.4, t);
                        s.scale.set(scale, scale, 1);
                        s.material.opacity = THREE.MathUtils.lerp(0.55, 0.15, t);
                    }
                }
            }
        }

        // ------------------------------------------------------------
        // Explosion Debris System (Pre-baked)
        // ------------------------------------------------------------
        function createDebrisPool() {
            // Create a pool of random debris pieces that look like meteor fragments
            debrisPool = [];
            
            for (let i = 0; i < debrisPoolSize; i++) {
                // Create random irregular shapes for debris
                const size = Math.random() * 0.2 + 0.15; // Random size between 0.15 and 0.35 (larger for visibility)
                
                // Use different geometries for variety
                let debrisGeo;
                const geoType = Math.random();
                if (geoType < 0.33) {
                    debrisGeo = new THREE.BoxGeometry(size, size * 0.8, size * 1.2);
                } else if (geoType < 0.66) {
                    debrisGeo = new THREE.OctahedronGeometry(size, 0);
                } else {
                    debrisGeo = new THREE.TetrahedronGeometry(size, 0);
                }
                
                // Create material - will be updated based on mode when used
                const debrisMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff6347,
                    transparent: true,
                    opacity: 1.0
                });
                
                const piece = new THREE.Mesh(debrisGeo, debrisMat);
                piece.visible = false; // Start hidden
                piece.castShadow = true;
                piece.receiveShadow = true;
                
                scene.add(piece);
                debrisPool.push(piece);
            }
        }
        
        function activateDebrisExplosion(position, meteorMaterial) {
            // Prototype mode: no debris/crumble effects.
            if (isPrototypeMode) return;

            // Activate debrisCount pieces from the pool for this explosion
            const availableDebris = debrisPool.filter(p => !p.visible);
            const countToUse = debrisCount; // Always try to use full count
            
            for (let i = 0; i < countToUse; i++) {
                let piece;
                
                // Get piece from pool if available, otherwise create new one dynamically
                if (i < availableDebris.length) {
                    piece = availableDebris[i];
                } else {
                    // Pool exhausted - create new piece dynamically
                    const size = Math.random() * 0.2 + 0.15;
                    let debrisGeo;
                    const geoType = Math.random();
                    if (geoType < 0.33) {
                        debrisGeo = new THREE.BoxGeometry(size, size * 0.8, size * 1.2);
                    } else if (geoType < 0.66) {
                        debrisGeo = new THREE.OctahedronGeometry(size, 0);
                    } else {
                        debrisGeo = new THREE.TetrahedronGeometry(size, 0);
                    }
                    
                    const debrisMat = new THREE.MeshStandardMaterial({ 
                        color: 0xff6347,
                        transparent: true,
                        opacity: 1.0
                    });
                    
                    piece = new THREE.Mesh(debrisGeo, debrisMat);
                    piece.castShadow = true;
                    piece.receiveShadow = true;
                    scene.add(piece);
                    debrisPool.push(piece); // Add to pool for future reuse
                }
                
                // Update material based on mode
                if (isPrototypeMode) {
                    piece.material.color.setHex(0xff6347);
                    piece.material.opacity = 1.0;
                    piece.material.transparent = true;
                } else if (meteorMaterial) {
                    // Clone the meteor's material for full mode
                    if (meteorMaterial.clone) {
                        const clonedMat = meteorMaterial.clone();
                        clonedMat.opacity = 1.0;
                        clonedMat.transparent = true;
                        piece.material = clonedMat;
                    } else {
                        // Fallback: use default color
                        piece.material.color.setHex(0xff6347);
                        piece.material.opacity = 1.0;
                        piece.material.transparent = true;
                    }
                } else {
                    // Default material
                    piece.material.color.setHex(0xff6347);
                    piece.material.opacity = 1.0;
                    piece.material.transparent = true;
                }
                
                // Reset piece state
                piece.position.copy(position);
                piece.position.y = Math.max(position.y, 0.2); // Ensure debris starts slightly above ground
                piece.visible = true;
                
                // Random initial rotation
                piece.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                // Random explosion velocity (outward in all directions)
                const angle = Math.random() * Math.PI * 2; // Random horizontal direction
                const verticalAngle = Math.random() * Math.PI * 0.5; // 0 to 90 degrees up
                const speed = Math.random() * 4 + 2; // Random speed between 2 and 6
                
                const velocity = new THREE.Vector3(
                    Math.cos(angle) * Math.sin(verticalAngle) * speed,
                    Math.cos(verticalAngle) * speed,
                    Math.sin(angle) * Math.sin(verticalAngle) * speed
                );
                
                // Random angular velocity for rotation
                const angularVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                
                // Store animation data
                activeDebris.push({
                    piece: piece,
                    velocity: velocity,
                    angularVelocity: angularVelocity,
                    startTime: Date.now() / 1000,
                    lifetime: debrisLifetime
                });
            }
        }
        
        function updateExplosionDebris(delta) {
            // Prototype mode: no debris/crumble effects.
            if (isPrototypeMode) return;

            const gravity = -9.8; // Gravity acceleration
            const currentTime = Date.now() / 1000;
            
            for (let i = activeDebris.length - 1; i >= 0; i--) {
                const data = activeDebris[i];
                const piece = data.piece;
                
                const elapsed = currentTime - data.startTime;
                const lifeProgress = elapsed / data.lifetime;
                
                // Remove if lifetime expired
                if (lifeProgress >= 1.0) {
                    piece.visible = false;
                    activeDebris.splice(i, 1);
                    continue;
                }
                
                // Apply physics
                // Update velocity (gravity affects Y)
                data.velocity.y += gravity * delta;
                
                // Update position
                piece.position.addScaledVector(data.velocity, delta);
                
                // Update rotation (same animation, but with random rotation)
                piece.rotation.x += data.angularVelocity.x * delta;
                piece.rotation.y += data.angularVelocity.y * delta;
                piece.rotation.z += data.angularVelocity.z * delta;
                
                // Fade out over time
                piece.material.opacity = 1.0 - lifeProgress;
                
                // Stop at ground level with bounce
                if (piece.position.y < 0.1) {
                    piece.position.y = 0.1;
                    data.velocity.y *= -0.3; // Bounce with energy loss
                    data.velocity.x *= 0.8; // Friction
                    data.velocity.z *= 0.8;
                    
                    // Slow down rotation when on ground
                    data.angularVelocity.multiplyScalar(0.9);
                }
            }
        }

        // ------------------------------------------------------------
        // Enemies update
        // ------------------------------------------------------------
        function updateEnemies(delta) {
            if (activeEnemyCount <= 0) return;
            if (!player) return;

            const enemySpeed = 2.6 + Math.min(4.0, score * 0.03);

            for (let i = 0; i < activeEnemyCount; i++) {
                const e = enemies[i];
                if (!e) continue;
                
                // Ensure enemy is still in scene and visible
                if (!scene.children.includes(e)) {
                    console.warn("Enemy", i, "not in scene, re-adding");
                    scene.add(e);
                }
                if (!e.visible) {
                    console.warn("Enemy", i, "not visible, making visible");
                    e.visible = true;
                    e.traverse(obj => { obj.visible = true; });
                }

                const dx = player.position.x - e.position.x;
                const dz = player.position.z - e.position.z;
                const d = Math.sqrt(dx*dx + dz*dz);

                if (d > 0.001) {
                    e.position.x += (dx / d) * enemySpeed * delta;
                    e.position.z += (dz / d) * enemySpeed * delta;
                    
                    // Make enemy face the player
                    // atan2(dx, dz) gives the angle in the XZ plane
                    // In Three.js, rotation.y rotates around Y axis (0 = +Z direction)
                    e.rotation.y = Math.atan2(dx, dz);
                }

                if (d > 60) {
                    spawnEnemyNearPlayer(e);
                }
            }
        }

        // ------------------------------------------------------------
        // Collisions
        // ------------------------------------------------------------
        function checkCollisions() {
            if (!player) return;

            const playerRadius = 0.9;
            const meteorRadius = 0.8;
            const enemyRadius = 0.9;

            const px = player.position.x;
            const py = player.position.y;
            const pz = player.position.z;

            for (const m of meteors) {
                const dx = m.position.x - px;
                const dy = m.position.y - py;
                const dz = m.position.z - pz;
                const r = playerRadius + meteorRadius;
                if (dx*dx + dy*dy + dz*dz < r*r) {
                    gameOver("Hit by a meteor!");
                    return;
                }
            }

            for (let i = 0; i < activeEnemyCount; i++) {
                const e = enemies[i];
                const dx = e.position.x - px;
                const dz = e.position.z - pz;
                const r = playerRadius + enemyRadius;
                if (dx*dx + dz*dz < r*r) {
                    gameOver("Caught by an enemy!");
                    return;
                }
            }
        }

        function gameOver(reason) {
            if (isGameOver) return;
            isGameOver = true;
            isFalling = false;

            const base = "Game over! Final score " + score.toFixed(1) + ".";
            const reasonText = reason ? " " + reason : "";
            statusMessage.style.color = "#ffcc66";
            statusMessage.textContent = base + reasonText + " Press R or switch mode to restart.";
        }

        // ------------------------------------------------------------
        // Hole detection using circular boundaries
        // ------------------------------------------------------------
        function isFullyInHole(x, z, playerRadius) {
            for (const h of holes) {
                // Calculate distance from player center to black hole center
                const dx = x - h.x;
                const dz = z - h.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                // Player's circle is fully inside black hole's circle if:
                // distance from centers + player radius <= black hole radius
                if (distance + playerRadius <= h.halfSize) {
                    return true;
                }
            }
            return false;
        }

        function findHoleAtPosition(x, z) {
            // Find the hole that contains this position
            for (const h of holes) {
                const dist = Math.sqrt(
                    Math.pow(x - h.x, 2) + Math.pow(z - h.z, 2)
                );
                if (dist <= h.halfSize) {
                    return h;
                }
            }
            return null;
        }

        // ------------------------------------------------------------
        // Resize
        // ------------------------------------------------------------
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });
    </script>
</body>
</html>



