<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Meteor Dodge 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #fff;
        }

        #canvasContainer {
            position: fixed;
            inset: 0;
        }

        canvas {
            display: block;
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.55);
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
        }

        #hud h1 {
            margin: 0 0 4px 0;
            font-size: 18px;
            font-weight: 600;
        }

        #groupInfo {
            font-size: 12px;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        #modeToggle {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
            pointer-events: auto;
        }

        #modeToggle button {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            background: #222;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        #modeToggle button.active {
            background: #4caf50;
            border-color: #4caf50;
        }

        #scoreDisplay {
            font-size: 13px;
            margin-bottom: 4px;
        }

        #statusMessage {
            font-size: 13px;
            color: #ffcc66;
            min-height: 1.2em;
            max-width: 260px;
        }

        #controls {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 120px;
            height: 120px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            pointer-events: auto;
        }

        #controls button {
            border: 1px solid #666;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
        }

        #controls button:active {
            background: #4caf50;
        }

        #controls button.empty {
            visibility: hidden;
        }

        #instructions {
            position: fixed;
            bottom: 12px;
            left: 12px;
            max-width: 320px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 8px;
            border-radius: 6px;
            line-height: 1.3;
        }

        @media (max-width: 600px) {
            #hud {
                font-size: 12px;
            }
            #hud h1 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>

    <div id="hud">
        <h1>Meteor Dodge 3D</h1>
        <div id="groupInfo">
            <!-- TODO: replace with your real group name and ID -->
            Group: Awesome Meteors • ID: <strong>1234</strong>
        </div>

        <div id="modeToggle">
            <span style="font-size:12px;">Mode:</span>
            <button id="btnPrototype" class="active">Prototype</button>
            <button id="btnFull">Full</button>
        </div>

        <div id="modeToggle">
            <span style="font-size:12px;">AI:</span>
            <button id="btnAI">OFF</button>
        </div>
        <div id="aiFeatures" style="margin-top:4px; font-size:11px; pointer-events:auto;">
            <label style="display:block;">
                <input type="checkbox" id="chkHoleAvoid" checked>
                Hole avoidance
            </label>
            <label style="display:block; margin-top:2px;">
                <input type="checkbox" id="chkThinkingTime" checked>
                Thinking time
            </label>
        </div>

        <div id="scoreDisplay">Score: 0.0</div>
        <div id="statusMessage"></div>
        <div id="aiLevelDisplay" style="font-size:12px; margin-top:4px; opacity:0.8;">
            AI Level: 5 (Intermediate)
        </div>
    </div>

    <div id="controls">
        <button class="empty"></button>
        <button data-dir="up">▲</button>
        <button class="empty"></button>

        <button data-dir="left">◀</button>
        <button class="empty"></button>
        <button data-dir="right">▶</button>

        <button class="empty"></button>
        <button data-dir="down">▼</button>
        <button class="empty"></button>
    </div>

    <div id="instructions">
        Keyboard: WASD / Arrow keys to move, R to restart.<br />
        AI: Press I to toggle, [ ] to adjust level (1-10).<br />
        Mobile: use the on-screen arrows and AI button.
    </div>

    <!-- THREE & loaders (keep your versions for OBJ/MTL compatibility) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/OBJLoader.js"></script>

    <!-- AI Computer Player -->
    <script src="computer.js"></script>

    <script>
    window.addEventListener("load", function () {
        // ------------------------------------------------------------
        // Global state
        // ------------------------------------------------------------
        let scene, camera, renderer;

        let player = null;

        // Meteors + shadows
        let meteors = [];
        let meteorShadows = [];
        let asteroidTemplate = null; // loaded OBJ for full-mode meteors

        // Enemies
        let enemies = [];
        let activeEnemyCount = 0;

        // Infinite floor
        let floorGroup = null;
        let floorTiles = [];
        let gridHelper = null;

        // Holes are dynamic (for visible tiles only)
        // Each entry: { x, z, halfSize }
        let holes = [];
        let holeMeshes = []; // visuals for holes (pooled per tile)

        const moveState = {
            left: false,
            right: false,
            forward: false,
            backward: false
        };

        let isPrototypeMode = true;
        let isGameOver = false;
        let isFalling = false;

        let score = 0;
        let lastTime = 0;
        let gameStartTime = 0; // Track when current game started
        
        // Player velocity tracking
        let playerVelocityX = 0;
        let playerVelocityZ = 0;
        let lastPlayerX = 0;
        let lastPlayerZ = 0;

        // AI
        let useAI = false;
        let aiLevel = 5;
        const computerAI = new ComputerAI();

        // Loaders
        let textureLoader;
        let gltfLoader;
        let mtlLoader;
        let objLoader;
        let rocketShipTemplate = null; // loaded OBJ for player
        
        // Simple texture cache
        const textures = {
            rocketBase: null,
            asteroidColor: null,
            asteroidNormal: null
        };

        // UI
        const scoreDisplay = document.getElementById("scoreDisplay");
        const statusMessage = document.getElementById("statusMessage");
        const aiLevelDisplay = document.getElementById("aiLevelDisplay");
        const btnPrototype = document.getElementById("btnPrototype");
        const btnFull = document.getElementById("btnFull");
        const btnAI = document.getElementById("btnAI");
        const chkHoleAvoid = document.getElementById("chkHoleAvoid");
        const chkThinkingTime = document.getElementById("chkThinkingTime");
        const canvasContainer = document.getElementById("canvasContainer");

        // Camera-aligned movement basis
        const camForward = new THREE.Vector3();
        const camRight = new THREE.Vector3();
        const tmpDir = new THREE.Vector3();
        const worldUp = new THREE.Vector3(0, 1, 0);

        const tmpV1 = new THREE.Vector3();

        // ------------------------------------------------------------
        // Performance / infinite arena config
        // ------------------------------------------------------------
        const tileSize = 32;
        const tileRadius = 1; // 3x3 tiles

        // Movement
        const playerSpeed = 12;

        // Falling animation
        const fallSpeed = 15;

        // Meteors scaling
        const baseMeteorCount = 24;
        const maxMeteorCount  = 90;
        const baseMeteorSpeed = 8;

        // Enemies scaling
        const enemyStartTime = 8; // seconds before first enemy
        const maxEnemyCount = 18;

        // Spawn radii relative to player
        const meteorSpawnRadiusMin = 6;
        const meteorSpawnRadiusMax = 18;
        const enemySpawnRadiusMin = 12;
        const enemySpawnRadiusMax = 22;

        // Camera follow
        const cameraOffset = new THREE.Vector3(26, 24, 26);
        const cameraTargetPos = new THREE.Vector3();
        const cameraLookAtPos = new THREE.Vector3();

        init();
        animate(0);

        // ------------------------------------------------------------
        // Initialization
        // ------------------------------------------------------------
        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050818);
            canvasContainer.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                240
            );
            camera.position.set(26, 24, 26);
            camera.lookAt(0, 0, 0);
            computeCameraBasis();

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(16, 26, 10);
            scene.add(dirLight);

            textureLoader = new THREE.TextureLoader();
            initTextures();

            gltfLoader = (typeof THREE.GLTFLoader !== "undefined") ? new THREE.GLTFLoader() : null;
            
            // OBJ / MTL loaders for asteroid and rocket models in full mode
            if (typeof THREE !== "undefined" && THREE.MTLLoader) {
                mtlLoader = new THREE.MTLLoader();
                mtlLoader.setPath("assets/");
            } else if (typeof MTLLoader !== "undefined") {
                mtlLoader = new MTLLoader();
                mtlLoader.setPath("assets/");
            } else {
                console.warn("MTLLoader not found; full-mode models will fall back to primitives.");
                mtlLoader = null;
            }

            if (typeof THREE !== "undefined" && THREE.OBJLoader) {
                objLoader = new THREE.OBJLoader();
                objLoader.setPath("assets/");
            } else if (typeof OBJLoader !== "undefined") {
                objLoader = new OBJLoader();
                objLoader.setPath("assets/");
            } else {
                console.warn("OBJLoader not found; full-mode models will fall back to primitives.");
                objLoader = null;
            }

            createSky();
            createInfiniteFloor();
            setMode(true);
            setupInput();

            window.addEventListener("resize", onWindowResize);
        }

        function initTextures() {
            // Rocket ship base color
            textures.rocketBase = textureLoader.load(
                "assets/Rocketship_baseColor.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Rocketship_baseColor.png");
                }
            );

            // Asteroid textures
            textures.asteroidColor = textureLoader.load(
                "assets/Asteroid2b_Color_1K.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Asteroid2b_Color_1K.png");
                }
            );

            textures.asteroidNormal = textureLoader.load(
                "assets/Asteroid2b_NormalGL_1K.png",
                undefined,
                undefined,
                function () {
                    console.warn("Failed to load Asteroid2b_NormalGL_1K.png");
                }
            );
        }

        function computeCameraBasis() {
            camera.getWorldDirection(tmpDir);
            camForward.set(tmpDir.x, 0, tmpDir.z).normalize();
            camRight.crossVectors(camForward, worldUp).normalize();
        }

        function createSky() {
            const skyGeo = new THREE.SphereGeometry(120, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0x050818,
                side: THREE.BackSide
            });
            const skySphere = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skySphere);
        }

        // ------------------------------------------------------------
        // Infinite floor (3x3 reusable tiles)
        // ------------------------------------------------------------
        function createInfiniteFloor() {
            floorGroup = new THREE.Group();
            floorTiles = [];
            holeMeshes = [];

            const floorGeo = new THREE.PlaneGeometry(tileSize, tileSize);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x777777 });

            for (let ox = -tileRadius; ox <= tileRadius; ox++) {
                for (let oz = -tileRadius; oz <= tileRadius; oz++) {
                    const tile = new THREE.Mesh(floorGeo, floorMat);
                    tile.rotation.x = -Math.PI / 2;
                    tile.userData.offsetX = ox;
                    tile.userData.offsetZ = oz;
                    tile.userData.tileX = 0;
                    tile.userData.tileZ = 0;
                    tile.userData.holeData = []; // generated per tile

                    tile.position.set(ox * tileSize, 0, oz * tileSize);
                    floorGroup.add(tile);
                    floorTiles.push(tile);

                    // Pre-allocate up to 2 visual hole pads per tile (cheap)
                    for (let i = 0; i < 2; i++) {
                        const hg = new THREE.PlaneGeometry(1, 1);
                        const hm = new THREE.MeshStandardMaterial({
                            color: 0x050505,
                            metalness: 0.1,
                            roughness: 0.9
                        });
                        const hmesh = new THREE.Mesh(hg, hm);
                        hmesh.rotation.x = -Math.PI / 2;
                        hmesh.position.y = 0.01;
                        hmesh.visible = false;
                        scene.add(hmesh);
                        holeMeshes.push(hmesh);
                    }
                }
            }

            scene.add(floorGroup);

            const gridSize = tileSize * (tileRadius * 2 + 1);
            gridHelper = new THREE.GridHelper(gridSize, (tileRadius * 2 + 1) * 8, 0x444444, 0x333333);
            gridHelper.position.y = 0.02;
            scene.add(gridHelper);
        }

        // Simple deterministic hash for procedural holes
        function hash2i(x, z) {
            let h = x * 374761393 + z * 668265263;
            h = (h ^ (h >> 13)) * 1274126177;
            h = h ^ (h >> 16);
            return h >>> 0;
        }
        function rand01(seed) {
            // xorshift-like
            seed ^= seed << 13; seed >>>= 0;
            seed ^= seed >> 17; seed >>>= 0;
            seed ^= seed << 5;  seed >>>= 0;
            return (seed % 10000) / 10000;
        }

        function generateHolesForTile(tileX, tileZ) {
            // 0-2 holes per tile, deterministic
            const baseSeed = hash2i(tileX, tileZ);

            const r = rand01(baseSeed);
            const holeCount = (r < 0.35) ? 0 : (r < 0.75 ? 1 : 2);

            const results = [];
            const margin = 5; // keep away from edges
            const usable = tileSize * 0.5 - margin;

            let seed = baseSeed;

            for (let i = 0; i < holeCount; i++) {
                seed = hash2i(seed, i + 11);

                const rx = rand01(seed);
                seed = hash2i(seed, i + 31);
                const rz = rand01(seed);

                // local offsets within tile
                const localX = THREE.MathUtils.lerp(-usable, usable, rx);
                const localZ = THREE.MathUtils.lerp(-usable, usable, rz);

                seed = hash2i(seed, i + 71);
                const sizeR = rand01(seed);
                const halfSize = THREE.MathUtils.lerp(1.6, 3.0, sizeR);

                results.push({ localX, localZ, halfSize });
            }

            return results;
        }

        function updateInfiniteFloorAndHoles() {
            if (!player) return;

            const cx = Math.floor(player.position.x / tileSize);
            const cz = Math.floor(player.position.z / tileSize);

            holes = []; // rebuild visible hole list each frame (small)

            // We'll reuse holeMeshes in order:
            let holeMeshIndex = 0;

            for (const tile of floorTiles) {
                const ox = tile.userData.offsetX;
                const oz = tile.userData.offsetZ;

                const tileX = cx + ox;
                const tileZ = cz + oz;

                // Move tile
                tile.position.x = tileX * tileSize;
                tile.position.z = tileZ * tileSize;

                // If tile identity changed, regenerate holes
                if (tile.userData.tileX !== tileX || tile.userData.tileZ !== tileZ) {
                    tile.userData.tileX = tileX;
                    tile.userData.tileZ = tileZ;
                    tile.userData.holeData = generateHolesForTile(tileX, tileZ);
                }

                // Place visual holes + push collision holes
                const hd = tile.userData.holeData;

                for (let i = 0; i < hd.length; i++) {
                    const h = hd[i];

                    const worldX = tile.position.x + h.localX;
                    const worldZ = tile.position.z + h.localZ;

                    holes.push({ x: worldX, z: worldZ, halfSize: h.halfSize });

                    const mesh = holeMeshes[holeMeshIndex++];
                    if (mesh) {
                        mesh.visible = true;
                        mesh.position.x = worldX;
                        mesh.position.z = worldZ;
                        mesh.scale.set(h.halfSize * 2, h.halfSize * 2, 1);
                    }
                }
            }

            // Hide unused hole meshes
            for (let i = holeMeshIndex; i < holeMeshes.length; i++) {
                holeMeshes[i].visible = false;
            }

            if (gridHelper) {
                gridHelper.position.x = cx * tileSize;
                gridHelper.position.z = cz * tileSize;
            }
        }

        // ------------------------------------------------------------
        // Camera follow
        // ------------------------------------------------------------
        function updateCameraFollow(delta) {
            if (!player) return;

            cameraTargetPos.set(
                player.position.x + cameraOffset.x,
                cameraOffset.y,
                player.position.z + cameraOffset.z
            );

            if (delta > 0) {
                const alpha = 1 - Math.pow(0.001, delta);
                camera.position.lerp(cameraTargetPos, alpha);
            } else {
                camera.position.copy(cameraTargetPos);
            }

            cameraLookAtPos.set(player.position.x, 0, player.position.z);
            camera.lookAt(cameraLookAtPos);

            computeCameraBasis();
        }

        // ------------------------------------------------------------
        // Mode switching
        // ------------------------------------------------------------
        function setMode(prototype) {
            isPrototypeMode = prototype;
            btnPrototype.classList.toggle("active", prototype);
            btnFull.classList.toggle("active", !prototype);

            resetGameState();
            clearDynamicObjects();

            if (isPrototypeMode) {
                createPrototypePlayer();
                statusMessage.textContent = "Prototype mode: primitive geometries only.";
            } else {
                createFullPlayer();
                statusMessage.textContent = "Full mode: using loaded objected and textures.";
            }

            // Create baseline meteors and enemies
            ensureMeteors(baseMeteorCount);
            ensureEnemies(0);

            updateAIStatus();
            updateCameraFollow(0);
        }

        function resetGameState() {
            isGameOver = false;
            isFalling = false;
            score = 0;
            lastTime = 0;
            gameStartTime = 0; // Reset game start time

            scoreDisplay.textContent = "Score: 0.0";
            statusMessage.textContent = "";

            // Reset player velocity tracking
            if (player) {
                lastPlayerX = player.position.x;
                lastPlayerZ = player.position.z;
            }
            playerVelocityX = 0;
            playerVelocityZ = 0;

            computerAI.reset();
        }

        function clearDynamicObjects() {
            if (player) {
                scene.remove(player);
                player = null;
            }

            meteors.forEach(m => scene.remove(m));
            meteorShadows.forEach(s => scene.remove(s));
            meteors = [];
            meteorShadows = [];

            enemies.forEach(e => scene.remove(e));
            enemies = [];
            activeEnemyCount = 0;
        }

        // ------------------------------------------------------------
        // Player
        // ------------------------------------------------------------
        function createPrototypePlayer() {
            const playerGeo = new THREE.BoxGeometry(1.5, 1, 2);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.set(0, 1, 0);
            player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
            scene.add(player);
            
            // Initialize player position tracking for velocity calculation
            lastPlayerX = player.position.x;
            lastPlayerZ = player.position.z;
            playerVelocityX = 0;
            playerVelocityZ = 0;
        }

        function createFullPlayer() {
            // Try OBJ/MTL loader first (rocket ship)
            if (rocketShipTemplate) {
                // Already loaded once – just clone
                player = rocketShipTemplate.clone();
                applyRocketMaterials(player);
                player.scale.set(1.5, 1.5, 1.5);
                player.position.set(0, 1, 0);
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
                lastPlayerX = player.position.x;
                lastPlayerZ = player.position.z;
                playerVelocityX = 0;
                playerVelocityZ = 0;
                updateCameraFollow(0);
            } else if (mtlLoader && objLoader) {
                // Load rocket from OBJ/MTL once
                const fallbackPlayer = createFallbackFullPlayer();
                player = fallbackPlayer;
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
                
                mtlLoader.load(
                    "cartoon_rocket_ship.mtl",
                    function (materials) {
                        materials.preload();
                        objLoader.setMaterials(materials);
                        objLoader.load(
                            "cartoon_rocket_ship.obj",
                            function (obj) {
                                rocketShipTemplate = obj;
                                if (player) scene.remove(player);

                                player = rocketShipTemplate.clone();
                                applyRocketMaterials(player);
                                player.scale.set(1.5, 1.5, 1.5);
                                player.position.set(0, 1, 0);
                                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                                scene.add(player);
                                lastPlayerX = player.position.x;
                                lastPlayerZ = player.position.z;
                                playerVelocityX = 0;
                                playerVelocityZ = 0;
                                updateCameraFollow(0);
                            },
                            undefined,
                            function (err) {
                                console.warn("Could not load rocket ship OBJ, using fallback player.", err);
                            }
                        );
                    },
                    undefined,
                    function (err) {
                        console.warn("Could not load rocket ship MTL, using fallback player.", err);
                    }
                );
            } else if (gltfLoader) {
                // Fallback to GLTF loader if available
                const fallback = createFallbackFullPlayer();
                player = fallback;
                scene.add(player);

                gltfLoader.load(
                    "assets/models/spaceship.glb",
                    function (gltf) {
                        if (player) scene.remove(player);
                        player = gltf.scene;
                        player.traverse(obj => {
                            if (obj.isMesh) {
                                obj.castShadow = true;
                                obj.receiveShadow = true;
                            }
                        });
                        player.scale.set(1.8, 1.8, 1.8);
                        player.position.set(0, 1, 0);
                        scene.add(player);
                        lastPlayerX = player.position.x;
                        lastPlayerZ = player.position.z;
                        playerVelocityX = 0;
                        playerVelocityZ = 0;
                        updateCameraFollow(0);
                    },
                    undefined,
                    function () {}
                );
            } else {
                // No loaders – use basic cylinder+cone
                const fallbackPlayer = createFallbackFullPlayer();
                player = fallbackPlayer;
                player.rotation.y = -Math.PI / 4; // 45 degrees clockwise from top-down
                scene.add(player);
            }
        }

        function createFallbackFullPlayer() {
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.8, 2.2, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00bcd4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);

            const noseGeo = new THREE.ConeGeometry(0.5, 1.0, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.y = 1.5;

            const group = new THREE.Group();
            group.add(body);
            group.add(nose);
            group.position.set(0, 1, 0);
            return group;
        }

        function applyRocketMaterials(root) {
            root.traverse(obj => {
                if (!obj.isMesh) return;

                obj.castShadow = true;
                obj.receiveShadow = true;

                if (textures.rocketBase) {
                    obj.material = new THREE.MeshStandardMaterial({
                        map: textures.rocketBase,
                        metalness: 0.3,
                        roughness: 0.6
                    });
                } else if (obj.material) {
                    obj.material = obj.material.clone();
                }
            });
        }

        function applyAsteroidMaterials(root) {
            root.traverse(obj => {
                if (!obj.isMesh) return;

                obj.castShadow = true;
                obj.receiveShadow = true;

                obj.material = new THREE.MeshStandardMaterial({
                    map: textures.asteroidColor || null,
                    normalMap: textures.asteroidNormal || null,
                    metalness: 0.1,
                    roughness: 0.9
                });
            });
        }

        // ------------------------------------------------------------
        // Meteors (pooled)
        // ------------------------------------------------------------
        function ensureMeteors(targetCount) {
            const count = Math.min(targetCount, maxMeteorCount);

            const shadowGeo = new THREE.CircleGeometry(0.9, 16);

            // Prototype meteors use spheres
            if (isPrototypeMode) {
                const meteorGeo = new THREE.SphereGeometry(0.8, 16, 16);
                const meteorMat = new THREE.MeshStandardMaterial({ color: 0xff6347 });

                while (meteors.length < count) {
                    const mesh = new THREE.Mesh(meteorGeo, meteorMat);
                    resetMeteorNearPlayer(mesh, true);
                    scene.add(mesh);
                    meteors.push(mesh);

                    const shadowMat = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.35
                    });
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.rotation.x = -Math.PI / 2;
                    shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                    scene.add(shadow);
                    meteorShadows.push(shadow);
                }
                return;
            }

            // Full mode: prefer OBJ asteroid if available
            function spawnMeteorFromPrototype(prototype) {
                const mesh = prototype.clone();
                mesh.traverse(obj => {
                    if (obj.isMesh) {
                        obj.castShadow = true;
                        obj.receiveShadow = true;
                    }
                });
                
                mesh.rotation.x = Math.random() * Math.PI * 2;
                mesh.rotation.y = Math.random() * Math.PI * 2;
                mesh.rotation.z = Math.random() * Math.PI * 2;

                const scale = Math.random() * 0.2 + 0.8;
                mesh.scale.set(scale, scale, scale);
                
                resetMeteorNearPlayer(mesh, true);
                scene.add(mesh);
                meteors.push(mesh);

                const shadowMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.35
                });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                scene.add(shadow);
                meteorShadows.push(shadow);
            }

            // If we already have a template, just clone until count reached
            if (asteroidTemplate) {
                while (meteors.length < count) {
                    spawnMeteorFromPrototype(asteroidTemplate);
                }
                return;
            }

            // Try loading asteroid once, then backfill
            if (mtlLoader && objLoader) {
                mtlLoader.load(
                    "Asteroid_2b.mtl",
                    function (materials) {
                        materials.preload();
                        objLoader.setMaterials(materials);
                        objLoader.load(
                            "Asteroid_2b.obj",
                            function (obj) {
                                asteroidTemplate = obj;
                                applyAsteroidMaterials(asteroidTemplate);
                                while (meteors.length < count) {
                                    spawnMeteorFromPrototype(asteroidTemplate);
                                }
                            },
                            undefined,
                            function () {
                                createFallbackRockMeteors(count);
                            }
                        );
                    },
                    undefined,
                    function () {
                        createFallbackRockMeteors(count);
                    }
                );
            } else {
                createFallbackRockMeteors(count);
            }

            function createFallbackRockMeteors(n) {
                const meteorGeo = new THREE.SphereGeometry(0.8, 24, 24);

                while (meteors.length < n) {
                    const mat = new THREE.MeshStandardMaterial({
                        map: textures.asteroidColor || null,
                        normalMap: textures.asteroidNormal || null,
                        metalness: 0.1,
                        roughness: 0.9
                    });

                    const mesh = new THREE.Mesh(meteorGeo, mat);
                    resetMeteorNearPlayer(mesh, true);
                    scene.add(mesh);
                    meteors.push(mesh);

                    const shadowMat = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.35
                    });
                    const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                    shadow.rotation.x = -Math.PI / 2;
                    shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                    scene.add(shadow);
                    meteorShadows.push(shadow);
                }
            }
        }

        function resetMeteorNearPlayer(meteor, randomHeight) {
            const centerX = player ? player.position.x : 0;
            const centerZ = player ? player.position.z : 0;

            const angle = Math.random() * Math.PI * 2;
            const dist = THREE.MathUtils.randFloat(meteorSpawnRadiusMin, meteorSpawnRadiusMax);

            meteor.position.x = centerX + Math.cos(angle) * dist;
            meteor.position.z = centerZ + Math.sin(angle) * dist;
            meteor.position.y = randomHeight
                ? THREE.MathUtils.randFloat(6, 24)
                : THREE.MathUtils.randFloat(14, 26);
            
            // Add horizontal velocity: random drift + player's current velocity
            const randomDriftX = THREE.MathUtils.randFloat(-0.5, 0.5);
            const randomDriftZ = THREE.MathUtils.randFloat(-0.5, 0.5);
            meteor.userData.velocityX = randomDriftX + playerVelocityX;
            meteor.userData.velocityZ = randomDriftZ + playerVelocityZ;
        }

        // ------------------------------------------------------------
        // Enemies (pooled chasers)
        // ------------------------------------------------------------
        function ensureEnemies(targetCount) {
            const count = Math.min(targetCount, maxEnemyCount);

            const enemyGeo = new THREE.BoxGeometry(1.4, 1.2, 1.4);
            const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });

            while (enemies.length < count) {
                const e = new THREE.Mesh(enemyGeo, enemyMat);
                e.position.y = 0.6;
                spawnEnemyNearPlayer(e);
                scene.add(e);
                enemies.push(e);
            }

            activeEnemyCount = Math.min(count, enemies.length);
        }

        function spawnEnemyNearPlayer(enemy) {
            const centerX = player ? player.position.x : 0;
            const centerZ = player ? player.position.z : 0;

            const angle = Math.random() * Math.PI * 2;
            const dist = THREE.MathUtils.randFloat(enemySpawnRadiusMin, enemySpawnRadiusMax);

            enemy.position.x = centerX + Math.cos(angle) * dist;
            enemy.position.z = centerZ + Math.sin(angle) * dist;
        }

        // ------------------------------------------------------------
        // Input handling
        // ------------------------------------------------------------
        function setupInput() {
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);

            btnPrototype.addEventListener("click", () => setMode(true));
            btnFull.addEventListener("click", () => setMode(false));
            btnAI.addEventListener("click", toggleAI);

            if (chkHoleAvoid) {
                chkHoleAvoid.addEventListener("change", () => {
                    if (computerAI.setHoleAvoidanceEnabled) {
                        computerAI.setHoleAvoidanceEnabled(chkHoleAvoid.checked);
                    }
                });
            }
            if (chkThinkingTime) {
                chkThinkingTime.addEventListener("change", () => {
                    if (computerAI.setThinkingTimeEnabled) {
                        computerAI.setThinkingTimeEnabled(chkThinkingTime.checked);
                    }
                });
            }

            const controlButtons = document.querySelectorAll("#controls button[data-dir]");
            controlButtons.forEach(btn => {
                const dir = btn.getAttribute("data-dir");

                function pressHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, true);
                }

                function releaseHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, false);
                }

                btn.addEventListener("mousedown", pressHandler);
                btn.addEventListener("mouseup", releaseHandler);
                btn.addEventListener("mouseleave", releaseHandler);

                btn.addEventListener("touchstart", pressHandler, { passive: false });
                btn.addEventListener("touchend", releaseHandler, { passive: false });
                btn.addEventListener("touchcancel", releaseHandler, { passive: false });
            });

            updateAIStatus();
        }

        function onKeyDown(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = true;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = true;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = true;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = true;

            if (e.key === "r" || e.key === "R") {
                setMode(isPrototypeMode);
            }

            if (e.key === "i" || e.key === "I") {
                useAI = !useAI;
                updateAIStatus();
            }

            if (e.key === "[" || e.key === "{") {
                aiLevel = Math.max(1, aiLevel - 1);
                updateAIStatus();
            }
            if (e.key === "]" || e.key === "}") {
                aiLevel = Math.min(10, aiLevel + 1);
                updateAIStatus();
            }
        }

        function onKeyUp(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = false;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = false;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = false;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = false;
        }

        function setMoveState(dir, value) {
            if (dir === "left") moveState.left = value;
            if (dir === "right") moveState.right = value;
            if (dir === "up") moveState.forward = value;
            if (dir === "down") moveState.backward = value;
        }

        function toggleAI() {
            useAI = !useAI;
            updateAIStatus();
        }

        function updateAIStatus() {
            btnAI.textContent = useAI ? "ON" : "OFF";
            btnAI.classList.toggle("active", useAI);

            const levelDesc = getLevelDescription(aiLevel);
            aiLevelDisplay.textContent = `AI Level: ${aiLevel} (${levelDesc})`;

            if (!isGameOver) {
                statusMessage.textContent = useAI
                    ? "AI ACTIVE - Press [ ] to adjust level, I to disable"
                    : "Manual control - Press I to enable AI";
                statusMessage.style.color = useAI ? "#4caf50" : "#ffcc66";
            }
        }

        function getLevelDescription(level) {
            if (level <= 3) return "Beginner";
            if (level <= 6) return "Intermediate";
            if (level <= 9) return "Advanced";
            return "Expert";
        }

        // ------------------------------------------------------------
        // Game loop
        // ------------------------------------------------------------
        function animate(timestamp) {
            requestAnimationFrame(animate);

            const t = timestamp * 0.001;
            const delta = lastTime ? t - lastTime : 0;
            lastTime = t;

            if (!player) {
                renderer.render(scene, camera);
                return;
            }

            // Track game start time (first frame after reset)
            if (gameStartTime === 0 && !isGameOver) {
                gameStartTime = t;
            }

            // Update floor + holes first so collision uses current holes
            updateInfiniteFloorAndHoles();

            if (!isGameOver) {
                const gameTime = gameStartTime > 0 ? t - gameStartTime : 0;
                updateDifficulty(gameTime);
                updatePlayer(delta);
                updateCameraFollow(delta);

                updateMeteors(delta);
                updateEnemies(delta);

                checkCollisions();

                score += delta;
                scoreDisplay.textContent = "Score: " + score.toFixed(1);
            } else {
                // Keep visuals alive
                updatePlayer(delta); // handles falling animation
                updateCameraFollow(delta);
                updateMeteors(delta);
                updateEnemies(delta);
            }

            renderer.render(scene, camera);
        }

        function updateDifficulty(liveTime) {
            const meteorTarget = Math.min(
                maxMeteorCount,
                baseMeteorCount + Math.floor(liveTime / 10) * 6
            );
            ensureMeteors(meteorTarget);

            let enemyTarget = 0;
            if (liveTime >= enemyStartTime) {
                enemyTarget = Math.min(
                    maxEnemyCount,
                    1 + Math.floor((liveTime - enemyStartTime) / 12)
                );
            }
            ensureEnemies(enemyTarget);
        }

        // ------------------------------------------------------------
        // Player update (keeps your falling logic)
        // ------------------------------------------------------------
        function updatePlayer(delta) {
            if (!player) return;

            const playerRadius = 0.9;

            // Trigger falling when fully inside a hole
            if (!isGameOver && isFullyInHole(player.position.x, player.position.z, playerRadius)) {
                isGameOver = true;
                isFalling = true;
                statusMessage.style.color = "#ffcc66";
            }

            if (isGameOver) {
                if (isFalling) {
                    player.position.y -= fallSpeed * delta;
                    if (player.position.y < -2 && !statusMessage.textContent.includes("Game over")) {
                        statusMessage.textContent =
                            "Game over! Final score " + score.toFixed(1) +
                            ". You fell into a hole! Press R or switch mode to restart.";
                    }
                }
                return;
            }

            // Input in screen space
            let ix = 0;
            let iz = 0;

            if (useAI && computerAI && computerAI.suggestMove) {
                const speedBoost = score * 0.15;
                const meteorFallSpeed = baseMeteorSpeed + speedBoost;

                const meteorData = meteors.map(m => ({
                    position: { x: m.position.x, y: m.position.y, z: m.position.z },
                    velocity: { 
                        x: m.userData.velocityX || 0, 
                        y: -meteorFallSpeed, 
                        z: m.userData.velocityZ || 0 
                    }
                }));

                const move = computerAI.suggestMove(
                    meteorData,
                    { x: player.position.x, y: player.position.y, z: player.position.z },
                    score,
                    aiLevel
                );

                const worldDx = move.dx || 0;
                const worldDz = move.dz || 0;

                ix = worldDx * camRight.x + worldDz * camRight.z;
                iz = worldDx * camForward.x + worldDz * camForward.z;
            } else {
                if (moveState.left)  ix -= 1;
                if (moveState.right) ix += 1;
                if (moveState.forward)  iz += 1;
                if (moveState.backward) iz -= 1;
            }

            // If no input, return to neutral tilt and exit
            if (ix === 0 && iz === 0) {
                player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, 0, 0.15);
                player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.15);
                return;
            }

            const len = Math.sqrt(ix * ix + iz * iz);
            ix /= len;
            iz /= len;

            const worldMove = new THREE.Vector3();
            worldMove.copy(camRight).multiplyScalar(ix);
            worldMove.addScaledVector(camForward, iz);

            const dist = playerSpeed * delta;
            player.position.x += worldMove.x * dist;
            player.position.z += worldMove.z * dist;
            
            // Calculate player velocity (for meteor drift)
            if (delta > 0) {
                playerVelocityX = (player.position.x - lastPlayerX) / delta;
                playerVelocityZ = (player.position.z - lastPlayerZ) / delta;
                lastPlayerX = player.position.x;
                lastPlayerZ = player.position.z;
            }

            // Tilt in the direction of movement (only when actually moving)
            const maxTilt = 0.35;
            const normalizedMove = new THREE.Vector3(worldMove.x, 0, worldMove.z).normalize();
            // Tilt forward/backward based on Z movement, left/right based on X movement
            // Forward (Z+) → tilt forward (rotation.x+), Backward (Z-) → tilt backward (rotation.x-)
            // Left (X-) → tilt left (rotation.z+), Right (X+) → tilt right (rotation.z-)
            const targetTiltX = THREE.MathUtils.clamp(normalizedMove.z * maxTilt, -maxTilt, maxTilt);
            const targetTiltZ = THREE.MathUtils.clamp(-normalizedMove.x * maxTilt, -maxTilt, maxTilt);
            
            player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, targetTiltX, 0.15);
            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, targetTiltZ, 0.15);
        }

        // ------------------------------------------------------------
        // Meteors update + shadows
        // ------------------------------------------------------------
        function updateMeteors(delta) {
            const speedBoost = score * 0.15;
            const fallSpeed = baseMeteorSpeed + speedBoost;

            for (let i = 0; i < meteors.length; i++) {
                const m = meteors[i];
                const s = meteorShadows[i];

                // Apply horizontal velocity
                if (m.userData.velocityX !== undefined) {
                    m.position.x += m.userData.velocityX * delta;
                    m.position.z += m.userData.velocityZ * delta;
                }
                
                m.position.y -= fallSpeed * delta;
                m.rotation.x += 0.8 * delta;
                m.rotation.y += 0.5 * delta;

                if (m.position.y < -4) {
                    resetMeteorNearPlayer(m, false);
                }

                if (s) {
                    s.position.x = m.position.x;
                    s.position.z = m.position.z;

                    const t = THREE.MathUtils.clamp((m.position.y - 2) / 18, 0, 1);
                    const scale = THREE.MathUtils.lerp(1.5, 0.4, t);
                    s.scale.set(scale, scale, 1);
                    s.material.opacity = THREE.MathUtils.lerp(0.55, 0.15, t);
                }
            }
        }

        // ------------------------------------------------------------
        // Enemies update
        // ------------------------------------------------------------
        function updateEnemies(delta) {
            if (activeEnemyCount <= 0) return;

            const enemySpeed = 2.6 + Math.min(4.0, score * 0.03);

            for (let i = 0; i < activeEnemyCount; i++) {
                const e = enemies[i];
                if (!e) continue;

                const dx = player.position.x - e.position.x;
                const dz = player.position.z - e.position.z;
                const d = Math.sqrt(dx*dx + dz*dz);

                if (d > 0.001) {
                    e.position.x += (dx / d) * enemySpeed * delta;
                    e.position.z += (dz / d) * enemySpeed * delta;
                }

                if (d > 60) {
                    spawnEnemyNearPlayer(e);
                }
            }
        }

        // ------------------------------------------------------------
        // Collisions
        // ------------------------------------------------------------
        function checkCollisions() {
            if (!player) return;

            const playerRadius = 0.9;
            const meteorRadius = 0.8;
            const enemyRadius = 0.9;

            const px = player.position.x;
            const py = player.position.y;
            const pz = player.position.z;

            for (const m of meteors) {
                const dx = m.position.x - px;
                const dy = m.position.y - py;
                const dz = m.position.z - pz;
                const r = playerRadius + meteorRadius;
                if (dx*dx + dy*dy + dz*dz < r*r) {
                    gameOver("Hit by a meteor!");
                    return;
                }
            }

            for (let i = 0; i < activeEnemyCount; i++) {
                const e = enemies[i];
                const dx = e.position.x - px;
                const dz = e.position.z - pz;
                const r = playerRadius + enemyRadius;
                if (dx*dx + dz*dz < r*r) {
                    gameOver("Caught by an enemy!");
                    return;
                }
            }
        }

        function gameOver(reason) {
            if (isGameOver) return;
            isGameOver = true;
            isFalling = false;

            const base = "Game over! Final score " + score.toFixed(1) + ".";
            const reasonText = reason ? " " + reason : "";
            statusMessage.style.color = "#ffcc66";
            statusMessage.textContent = base + reasonText + " Press R or switch mode to restart.";
        }

        // ------------------------------------------------------------
        // Hole detection (same rules you used)
        // ------------------------------------------------------------
        function isFullyInHole(x, z, playerRadius) {
            for (const h of holes) {
                const leftEdge = x - playerRadius;
                const rightEdge = x + playerRadius;
                const frontEdge = z - playerRadius;
                const backEdge = z + playerRadius;

                const holeLeft = h.x - h.halfSize;
                const holeRight = h.x + h.halfSize;
                const holeFront = h.z - h.halfSize;
                const holeBack = h.z + h.halfSize;

                if (leftEdge >= holeLeft && rightEdge <= holeRight &&
                    frontEdge >= holeFront && backEdge <= holeBack) {
                    return true;
                }
            }
            return false;
        }

        // ------------------------------------------------------------
        // Resize
        // ------------------------------------------------------------
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });
    </script>
</body>
</html>



