<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Meteor Dodge 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #fff;
        }

        #canvasContainer {
            position: fixed;
            inset: 0;
        }

        canvas {
            display: block;
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.55);
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
        }

        #hud h1 {
            margin: 0 0 4px 0;
            font-size: 18px;
            font-weight: 600;
        }

        #groupInfo {
            font-size: 12px;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        .toggleRow {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            pointer-events: auto;
        }

        .toggleRow button {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            background: #222;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        .toggleRow button.active {
            background: #4caf50;
            border-color: #4caf50;
        }

        #scoreDisplay {
            font-size: 13px;
            margin-bottom: 4px;
        }

        #statusMessage {
            font-size: 13px;
            color: #ffcc66;
            min-height: 1.2em;
            max-width: 280px;
        }

        #controls {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 120px;
            height: 120px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            pointer-events: auto;
        }

        #controls button {
            border: 1px solid #666;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
        }

        #controls button:active {
            background: #4caf50;
        }

        #controls button.empty {
            visibility: hidden;
        }

        #instructions {
            position: fixed;
            bottom: 12px;
            left: 12px;
            max-width: 360px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 8px;
            border-radius: 6px;
            line-height: 1.3;
        }

        @media (max-width: 600px) {
            #hud {
                font-size: 12px;
            }
            #hud h1 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>

    <div id="hud">
        <h1>Meteor Dodge 3D</h1>
        <div id="groupInfo">
            <!-- TODO: replace with your real group name and ID -->
            Group: Awesome Meteors • ID: <strong>1234</strong>
        </div>

        <div class="toggleRow">
            <span style="font-size:12px;">Mode:</span>
            <button id="btnPrototype" class="active">Prototype</button>
            <button id="btnFull">Full</button>
        </div>

        <div id="scoreDisplay">Score: 0.0</div>
        <div id="statusMessage"></div>
    </div>

    <div id="controls">
        <button class="empty"></button>
        <button data-dir="up">▲</button>
        <button class="empty"></button>

        <button data-dir="left">◀</button>
        <button class="empty"></button>
        <button data-dir="right">▶</button>

        <button class="empty"></button>
        <button data-dir="down">▼</button>
        <button class="empty"></button>
    </div>

    <div id="instructions">
        Keyboard: WASD / Arrow keys to move, R to restart.<br />
        Mobile: use the on-screen arrows.<br />
        Infinite arena + enemies + meteor scaling enabled.
    </div>

    <!-- THREE & GLTFLoader -->
    <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.154.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
    window.addEventListener("load", function () {
        // ------------------------------------------------------------
        // Scene / renderer
        // ------------------------------------------------------------
        let scene, camera, renderer;

        // ------------------------------------------------------------
        // Player
        // ------------------------------------------------------------
        let player = null;

        // ------------------------------------------------------------
        // Meteors + shadow disks
        // ------------------------------------------------------------
        let meteors = [];
        let meteorShadows = [];

        // ------------------------------------------------------------
        // Enemies (simple chasers)
        // ------------------------------------------------------------
        let enemies = [];
        let activeEnemyCount = 0;

        // ------------------------------------------------------------
        // Infinite floor tiling
        // ------------------------------------------------------------
        let floorGroup = null;
        let floorTiles = [];
        let gridHelper = null;

        // ------------------------------------------------------------
        // Loaders
        // ------------------------------------------------------------
        let textureLoader;
        let gltfLoader;

        // ------------------------------------------------------------
        // UI
        // ------------------------------------------------------------
        const scoreDisplay = document.getElementById("scoreDisplay");
        const statusMessage = document.getElementById("statusMessage");
        const btnPrototype = document.getElementById("btnPrototype");
        const btnFull = document.getElementById("btnFull");
        const canvasContainer = document.getElementById("canvasContainer");

        // ------------------------------------------------------------
        // Controls
        // ------------------------------------------------------------
        const moveState = { left:false, right:false, forward:false, backward:false };

        // ------------------------------------------------------------
        // Game state
        // ------------------------------------------------------------
        let isPrototypeMode = true;
        let isGameOver = false;
        let score = 0;
        let lastTime = 0;

        // ------------------------------------------------------------
        // Infinite arena settings
        // ------------------------------------------------------------
        const tileSize = 32;      // plane size per tile
        const tileRadius = 1;    // 3x3 total

        // ------------------------------------------------------------
        // Difficulty scaling
        // ------------------------------------------------------------
        const baseMeteorCount = 24;
        const maxMeteorCount  = 90;

        const enemyStartTime  = 8;   // seconds
        const maxEnemyCount   = 18;

        // ------------------------------------------------------------
        // Movement + speed
        // ------------------------------------------------------------
        const playerSpeed = 12;
        const baseMeteorSpeed = 8;

        // Spawn relative to player
        const meteorSpawnRadiusMin = 6;
        const meteorSpawnRadiusMax = 18;

        const enemySpawnRadiusMin = 12;
        const enemySpawnRadiusMax = 22;

        // ------------------------------------------------------------
        // Camera follow
        // ------------------------------------------------------------
        const cameraOffset = new THREE.Vector3(26, 24, 26);
        const cameraTargetPos = new THREE.Vector3();
        const cameraLookAtPos = new THREE.Vector3();

        // Camera-aligned movement basis
        const camForward = new THREE.Vector3();
        const camRight = new THREE.Vector3();
        const tmpDir = new THREE.Vector3();
        const worldUp = new THREE.Vector3(0, 1, 0);

        const tmpV1 = new THREE.Vector3();
        const tmpV2 = new THREE.Vector3();

        init();
        animate(0);

        // ------------------------------------------------------------
        // Init
        // ------------------------------------------------------------
        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050818);
            canvasContainer.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                300
            );
            camera.position.set(26, 24, 26);
            camera.lookAt(0, 0, 0);
            computeCameraBasis();

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(16, 26, 10);
            scene.add(dirLight);

            textureLoader = new THREE.TextureLoader();

            if (THREE.GLTFLoader) {
                gltfLoader = new THREE.GLTFLoader();
            } else if (typeof GLTFLoader !== "undefined") {
                gltfLoader = new GLTFLoader();
            } else {
                gltfLoader = null;
            }

            createSky();
            createInfiniteFloor();

            setMode(true);
            setupInput();

            window.addEventListener("resize", onWindowResize);
        }

        function computeCameraBasis() {
            camera.getWorldDirection(tmpDir);
            camForward.set(tmpDir.x, 0, tmpDir.z).normalize();
            camRight.crossVectors(camForward, worldUp).normalize();
        }

        function createSky() {
            const skyGeo = new THREE.SphereGeometry(120, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0x050818,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);
        }

        // ------------------------------------------------------------
        // Infinite floor: 3x3 reusable tiles
        // ------------------------------------------------------------
        function createInfiniteFloor() {
            floorGroup = new THREE.Group();
            floorTiles = [];

            const floorGeo = new THREE.PlaneGeometry(tileSize, tileSize);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

            for (let ox = -tileRadius; ox <= tileRadius; ox++) {
                for (let oz = -tileRadius; oz <= tileRadius; oz++) {
                    const tile = new THREE.Mesh(floorGeo, floorMat);
                    tile.rotation.x = -Math.PI / 2;
                    tile.userData.offsetX = ox;
                    tile.userData.offsetZ = oz;
                    tile.position.set(ox * tileSize, 0, oz * tileSize);
                    floorGroup.add(tile);
                    floorTiles.push(tile);
                }
            }

            scene.add(floorGroup);

            const gridSize = tileSize * (tileRadius * 2 + 1);
            gridHelper = new THREE.GridHelper(gridSize, (tileRadius * 2 + 1) * 8, 0x444444, 0x333333);
            gridHelper.position.y = 0.02;
            scene.add(gridHelper);
        }

        function updateInfiniteFloor() {
            if (!player) return;

            const cx = Math.floor(player.position.x / tileSize);
            const cz = Math.floor(player.position.z / tileSize);

            for (const tile of floorTiles) {
                const ox = tile.userData.offsetX;
                const oz = tile.userData.offsetZ;
                tile.position.x = (cx + ox) * tileSize;
                tile.position.z = (cz + oz) * tileSize;
            }

            if (gridHelper) {
                gridHelper.position.x = cx * tileSize;
                gridHelper.position.z = cz * tileSize;
            }
        }

        // ------------------------------------------------------------
        // Camera follow
        // ------------------------------------------------------------
        function updateCameraFollow(delta) {
            if (!player) return;

            cameraTargetPos.set(
                player.position.x + cameraOffset.x,
                cameraOffset.y,
                player.position.z + cameraOffset.z
            );

            if (delta > 0) {
                const alpha = 1 - Math.pow(0.001, delta);
                camera.position.lerp(cameraTargetPos, alpha);
            } else {
                camera.position.copy(cameraTargetPos);
            }

            cameraLookAtPos.set(player.position.x, 0, player.position.z);
            camera.lookAt(cameraLookAtPos);

            computeCameraBasis();
        }

        // ------------------------------------------------------------
        // Mode switching
        // ------------------------------------------------------------
        function setMode(prototype) {
            isPrototypeMode = prototype;
            btnPrototype.classList.toggle("active", prototype);
            btnFull.classList.toggle("active", !prototype);

            resetGameState();
            clearDynamicObjects();

            if (isPrototypeMode) {
                createPrototypePlayer();
            } else {
                createFullPlayer();
            }

            ensureMeteors(baseMeteorCount);
            ensureEnemies(0);

            updateCameraFollow(0);
            statusMessage.textContent = isPrototypeMode ? "Prototype mode." : "Full mode.";
        }

        function resetGameState() {
            isGameOver = false;
            score = 0;
            lastTime = 0;
            scoreDisplay.textContent = "Score: 0.0";
            statusMessage.textContent = "";
        }

        function clearDynamicObjects() {
            if (player) { scene.remove(player); player = null; }

            for (const m of meteors) scene.remove(m);
            for (const s of meteorShadows) scene.remove(s);
            meteors = [];
            meteorShadows = [];

            for (const e of enemies) scene.remove(e);
            enemies = [];
            activeEnemyCount = 0;
        }

        // ------------------------------------------------------------
        // Player
        // ------------------------------------------------------------
        function createPrototypePlayer() {
            const geo = new THREE.BoxGeometry(1.5, 1, 2);
            const mat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            player = new THREE.Mesh(geo, mat);
            player.position.set(0, 1, 0);
            scene.add(player);
        }

        function createFullPlayer() {
            const fallback = createFallbackFullPlayer();
            player = fallback;
            scene.add(player);

            if (!gltfLoader) return;

            gltfLoader.load(
                "assets/models/spaceship.glb",
                (gltf) => {
                    if (player) scene.remove(player);
                    player = gltf.scene;
                    player.scale.set(1.8, 1.8, 1.8);
                    player.position.set(0, 1, 0);
                    scene.add(player);
                    updateCameraFollow(0);
                },
                undefined,
                () => {}
            );
        }

        function createFallbackFullPlayer() {
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.8, 2.2, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00bcd4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);

            const noseGeo = new THREE.ConeGeometry(0.5, 1.0, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.y = 1.5;

            const group = new THREE.Group();
            group.add(body);
            group.add(nose);
            group.position.set(0, 1, 0);
            return group;
        }

        // ------------------------------------------------------------
        // Meteors (pooled)
        // ------------------------------------------------------------
        function ensureMeteors(count) {
            count = Math.min(count, maxMeteorCount);

            const meteorGeo = isPrototypeMode
                ? new THREE.SphereGeometry(0.8, 12, 12)
                : new THREE.SphereGeometry(0.8, 18, 18);

            const shadowGeo = new THREE.CircleGeometry(0.9, 14);

            let meteorMat;
            if (isPrototypeMode) {
                meteorMat = new THREE.MeshStandardMaterial({ color: 0xff6347 });
            } else {
                const rockTexture = textureLoader.load("assets/textures/rock.jpg");
                meteorMat = new THREE.MeshStandardMaterial({ map: rockTexture, color: 0xffffff });
            }

            while (meteors.length < count) {
                const m = new THREE.Mesh(meteorGeo, meteorMat);
                resetMeteorNearPlayer(m, true);
                scene.add(m);
                meteors.push(m);

                const shadowMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.35
                });
                const s = new THREE.Mesh(shadowGeo, shadowMat);
                s.rotation.x = -Math.PI / 2;
                s.position.y = 0.02;
                scene.add(s);
                meteorShadows.push(s);
            }
        }

        function resetMeteorNearPlayer(meteor, randomHeight) {
            const centerX = player ? player.position.x : 0;
            const centerZ = player ? player.position.z : 0;

            const angle = Math.random() * Math.PI * 2;
            const dist = THREE.MathUtils.randFloat(meteorSpawnRadiusMin, meteorSpawnRadiusMax);

            meteor.position.x = centerX + Math.cos(angle) * dist;
            meteor.position.z = centerZ + Math.sin(angle) * dist;
            meteor.position.y = randomHeight
                ? THREE.MathUtils.randFloat(8, 26)
                : THREE.MathUtils.randFloat(14, 28);
        }

        // ------------------------------------------------------------
        // Enemies (pooled)
        // ------------------------------------------------------------
        function ensureEnemies(count) {
            count = Math.min(count, maxEnemyCount);

            const enemyGeo = new THREE.BoxGeometry(1.4, 1.2, 1.4);
            const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });

            while (enemies.length < count) {
                const e = new THREE.Mesh(enemyGeo, enemyMat);
                e.position.y = 0.6;
                spawnEnemyNearPlayer(e);
                scene.add(e);
                enemies.push(e);
            }

            activeEnemyCount = Math.min(count, enemies.length);
        }

        function spawnEnemyNearPlayer(enemy) {
            const centerX = player ? player.position.x : 0;
            const centerZ = player ? player.position.z : 0;

            const angle = Math.random() * Math.PI * 2;
            const dist = THREE.MathUtils.randFloat(enemySpawnRadiusMin, enemySpawnRadiusMax);

            enemy.position.x = centerX + Math.cos(angle) * dist;
            enemy.position.z = centerZ + Math.sin(angle) * dist;
        }

        // ------------------------------------------------------------
        // Input
        // ------------------------------------------------------------
        function setupInput() {
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);

            btnPrototype.addEventListener("click", () => setMode(true));
            btnFull.addEventListener("click", () => setMode(false));

            const controlButtons = document.querySelectorAll("#controls button[data-dir]");
            controlButtons.forEach(btn => {
                const dir = btn.getAttribute("data-dir");

                const press = (e) => { e.preventDefault(); setMoveState(dir, true); };
                const release = (e) => { e.preventDefault(); setMoveState(dir, false); };

                btn.addEventListener("mousedown", press);
                btn.addEventListener("mouseup", release);
                btn.addEventListener("mouseleave", release);

                btn.addEventListener("touchstart", press, { passive:false });
                btn.addEventListener("touchend", release, { passive:false });
                btn.addEventListener("touchcancel", release, { passive:false });
            });
        }

        function onKeyDown(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = true;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = true;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = true;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = true;

            if (e.key === "r" || e.key === "R") {
                setMode(isPrototypeMode);
            }
        }

        function onKeyUp(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = false;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = false;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = false;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = false;
        }

        function setMoveState(dir, value) {
            if (dir === "left") moveState.left = value;
            if (dir === "right") moveState.right = value;
            if (dir === "up") moveState.forward = value;
            if (dir === "down") moveState.backward = value;
        }

        // ------------------------------------------------------------
        // Main loop
        // ------------------------------------------------------------
        function animate(timestamp) {
            requestAnimationFrame(animate);

            const t = timestamp * 0.001;
            const delta = lastTime ? (t - lastTime) : 0;
            lastTime = t;

            if (!player) {
                renderer.render(scene, camera);
                return;
            }

            if (!isGameOver) {
                updateDifficulty(t);
                updatePlayer(delta);
                updateCameraFollow(delta);

                updateMeteors(delta);
                updateEnemies(delta);
                checkCollisions();

                score += delta;
                scoreDisplay.textContent = "Score: " + score.toFixed(1);
            } else {
                updateCameraFollow(delta);
                updateMeteors(delta);
                updateEnemies(delta);
            }

            updateInfiniteFloor();
            renderer.render(scene, camera);
        }

        // ------------------------------------------------------------
        // Difficulty scaling
        // ------------------------------------------------------------
        function updateDifficulty(liveTime) {
            const meteorTarget = Math.min(
                maxMeteorCount,
                baseMeteorCount + Math.floor(liveTime / 10) * 6
            );
            ensureMeteors(meteorTarget);

            let enemyTarget = 0;
            if (liveTime >= enemyStartTime) {
                enemyTarget = Math.min(
                    maxEnemyCount,
                    1 + Math.floor((liveTime - enemyStartTime) / 12)
                );
            }
            ensureEnemies(enemyTarget);
        }

        // ------------------------------------------------------------
        // Player update (camera-aligned movement)
        // ------------------------------------------------------------
        function updatePlayer(delta) {
            if (!player || delta <= 0) return;

            let ix = 0, iz = 0;

            if (moveState.left)  ix -= 1;
            if (moveState.right) ix += 1;
            if (moveState.forward)  iz += 1;  // screen up
            if (moveState.backward) iz -= 1;  // screen down

            if (ix === 0 && iz === 0) return;

            const len = Math.sqrt(ix*ix + iz*iz);
            ix /= len; iz /= len;

            tmpV1.copy(camRight).multiplyScalar(ix);
            tmpV1.addScaledVector(camForward, iz);

            const dist = playerSpeed * delta;
            player.position.x += tmpV1.x * dist;
            player.position.z += tmpV1.z * dist;

            // Small tilt
            const maxTilt = 0.35;
            const targetTiltZ = THREE.MathUtils.clamp(-ix * maxTilt, -maxTilt, maxTilt);
            const targetTiltX = THREE.MathUtils.clamp(-iz * maxTilt, -maxTilt, maxTilt);

            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, targetTiltZ, 0.15);
            player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, targetTiltX, 0.15);
        }

        // ------------------------------------------------------------
        // Meteors
        // ------------------------------------------------------------
        function updateMeteors(delta) {
            if (delta <= 0) return;

            const speedBoost = score * 0.15;
            const fallSpeed = baseMeteorSpeed + speedBoost;

            for (let i = 0; i < meteors.length; i++) {
                const m = meteors[i];
                const s = meteorShadows[i];

                m.position.y -= fallSpeed * delta;
                m.rotation.x += 0.8 * delta;
                m.rotation.y += 0.5 * delta;

                if (m.position.y < -4) {
                    resetMeteorNearPlayer(m, false);
                }

                if (s) {
                    s.position.x = m.position.x;
                    s.position.z = m.position.z;

                    const t = THREE.MathUtils.clamp((m.position.y - 2) / 22, 0, 1);
                    const scale = THREE.MathUtils.lerp(1.6, 0.45, t);
                    s.scale.set(scale, scale, 1);
                    s.material.opacity = THREE.MathUtils.lerp(0.58, 0.12, t);
                }
            }
        }

        // ------------------------------------------------------------
        // Enemies update
        // ------------------------------------------------------------
        function updateEnemies(delta) {
            if (delta <= 0 || activeEnemyCount <= 0) return;

            const enemySpeed = 2.6 + Math.min(4.0, score * 0.03);

            for (let i = 0; i < activeEnemyCount; i++) {
                const e = enemies[i];
                if (!e) continue;

                const dx = player.position.x - e.position.x;
                const dz = player.position.z - e.position.z;
                const d = Math.sqrt(dx*dx + dz*dz);

                if (d > 0.001) {
                    e.position.x += (dx / d) * enemySpeed * delta;
                    e.position.z += (dz / d) * enemySpeed * delta;
                }

                if (d > 60) {
                    spawnEnemyNearPlayer(e);
                }
            }
        }

        // ------------------------------------------------------------
        // Collisions
        // ------------------------------------------------------------
        function checkCollisions() {
            const playerRadius = 0.9;
            const meteorRadius = 0.8;
            const enemyRadius  = 0.9;

            // Meteor hit
            for (const m of meteors) {
                const dx = m.position.x - player.position.x;
                const dy = m.position.y - player.position.y;
                const dz = m.position.z - player.position.z;
                const r = playerRadius + meteorRadius;

                if (dx*dx + dy*dy + dz*dz < r*r) {
                    gameOver("Hit by a meteor!");
                    return;
                }
            }

            // Enemy hit
            for (let i = 0; i < activeEnemyCount; i++) {
                const e = enemies[i];
                const dx = e.position.x - player.position.x;
                const dz = e.position.z - player.position.z;
                const r = playerRadius + enemyRadius;

                if (dx*dx + dz*dz < r*r) {
                    gameOver("Caught by an enemy!");
                    return;
                }
            }
        }

        function gameOver(reason) {
            if (isGameOver) return;
            isGameOver = true;
            statusMessage.textContent =
                "Game over! Final score " + score.toFixed(1) + ". " +
                (reason || "") + " Press R or switch mode to restart.";
        }

        // ------------------------------------------------------------
        // Resize
        // ------------------------------------------------------------
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });
    </script>
</body>
</html>


