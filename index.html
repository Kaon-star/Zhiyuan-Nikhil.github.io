<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Meteor Dodge 3D</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #fff;
        }

        #canvasContainer {
            position: fixed;
            inset: 0;
        }

        canvas {
            display: block;
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.55);
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
        }

        #hud h1 {
            margin: 0 0 4px 0;
            font-size: 18px;
            font-weight: 600;
        }

        #groupInfo {
            font-size: 12px;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        #modeToggle {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 6px;
            pointer-events: auto;
        }

        #modeToggle button {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            background: #222;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        #modeToggle button.active {
            background: #4caf50;
            border-color: #4caf50;
        }

        #scoreDisplay {
            font-size: 13px;
            margin-bottom: 4px;
        }

        #statusMessage {
            font-size: 13px;
            color: #ffcc66;
            min-height: 1.2em;
            max-width: 260px;
        }

        #controls {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 120px;
            height: 120px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            pointer-events: auto;
        }

        #controls button {
            border: 1px solid #666;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
        }

        #controls button:active {
            background: #4caf50;
        }

        #controls button.empty {
            visibility: hidden;
        }

        #instructions {
            position: fixed;
            bottom: 12px;
            left: 12px;
            max-width: 320px;
            font-size: 11px;
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 8px;
            border-radius: 6px;
            line-height: 1.3;
        }

        @media (max-width: 600px) {
            #hud {
                font-size: 12px;
            }
            #hud h1 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div>

    <div id="hud">
        <h1>Meteor Dodge 3D</h1>
        <div id="groupInfo">
            <!-- TODO: replace with your real group name and ID -->
            Group: Awesome Meteors • ID: <strong>1234</strong>
        </div>

        <div id="modeToggle">
            <span style="font-size:12px;">Mode:</span>
            <button id="btnPrototype" class="active">Prototype</button>
            <button id="btnFull">Full</button>
        </div>

        <div id="scoreDisplay">Score: 0.0</div>
        <div id="statusMessage"></div>
    </div>

    <div id="controls">
        <button class="empty"></button>
        <button data-dir="up">▲</button>
        <button class="empty"></button>

        <button data-dir="left">◀</button>
        <button class="empty"></button>
        <button data-dir="right">▶</button>

        <button class="empty"></button>
        <button data-dir="down">▼</button>
        <button class="empty"></button>
    </div>

    <div id="instructions">
        Keyboard: WASD / Arrow keys to move, R to restart.<br />
        Mobile: use the on-screen arrows.
    </div>

    <!-- THREE & GLTFLoader from CDN (0.154.0, has build/three.min.js) -->
    <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.154.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
    window.addEventListener("load", function () {
        // ------------------------------------------------------------
        // Global state
        // ------------------------------------------------------------
        let scene, camera, renderer;

        let player = null;
        let meteors = [];
        let meteorShadows = []; // NEW: shadow disk for each meteor
        let platform = null;
        let skySphere = null;
        let walls = [];
        let holes = []; // {mesh, x, z, halfSize}

        const moveState = {
            left: false,
            right: false,
            forward: false,
            backward: false
        };

        let isPrototypeMode = true;
        let isGameOver = false;
        let score = 0;
        let lastTime = 0;
        const meteorCount = 24;
        const worldSize = 28;  // bigger arena
        const playerSpeed = 12;
        const baseMeteorSpeed = 8;

        let textureLoader;
        let gltfLoader;

        const scoreDisplay = document.getElementById("scoreDisplay");
        const statusMessage = document.getElementById("statusMessage");
        const btnPrototype = document.getElementById("btnPrototype");
        const btnFull = document.getElementById("btnFull");
        const canvasContainer = document.getElementById("canvasContainer");

        // Camera-aligned movement basis
        const camForward = new THREE.Vector3();
        const camRight = new THREE.Vector3();
        const tmpDir = new THREE.Vector3();
        const worldUp = new THREE.Vector3(0, 1, 0);

        init();
        animate(0);

        // ------------------------------------------------------------
        // Initialization
        // ------------------------------------------------------------
        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x050818);
            canvasContainer.appendChild(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                200
            );
            // fixed 2.5D angle (corner view)
            camera.position.set(26, 24, 26);
            camera.lookAt(0, 0, 0);
            computeCameraBasis();

            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(16, 26, 10);
            scene.add(dirLight);

            textureLoader = new THREE.TextureLoader();

            if (THREE.GLTFLoader) {
                gltfLoader = new THREE.GLTFLoader();
            } else if (typeof GLTFLoader !== "undefined") {
                gltfLoader = new GLTFLoader();
            } else {
                console.warn("GLTFLoader not found; full mode will use fallback player.");
                gltfLoader = null;
            }

            createBaseWorld();
            setMode(true);
            setupInput();
            window.addEventListener("resize", onWindowResize);
        }

        function computeCameraBasis() {
            // Camera forward in world coordinates
            camera.getWorldDirection(tmpDir);
            // Flatten to XZ plane
            camForward.set(tmpDir.x, 0, tmpDir.z).normalize();        // "up" on screen
            camRight.crossVectors(camForward, worldUp).normalize();   // "right" on screen
        }

        function createBaseWorld() {
            const geo = new THREE.PlaneGeometry(worldSize, worldSize);
            const mat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            platform = new THREE.Mesh(geo, mat);
            platform.rotation.x = -Math.PI / 2;
            platform.receiveShadow = true;
            scene.add(platform);

            // NEW: grid helper on top of the platform for depth cues
            const grid = new THREE.GridHelper(worldSize, 8, 0x444444, 0x333333);
            grid.position.y = 0.02;
            scene.add(grid);

            const skyGeo = new THREE.SphereGeometry(80, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0x050818,
                side: THREE.BackSide
            });
            skySphere = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skySphere);

            createWallsAndHoles();
        }

        function createWallsAndHoles() {
            const half = worldSize * 0.5;
            const wallHeight = 2.2;
            const wallThickness = 0.6;
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });

            const wallGeoZ = new THREE.BoxGeometry(worldSize, wallHeight, wallThickness);
            const wallGeoX = new THREE.BoxGeometry(wallThickness, wallHeight, worldSize);

            const north = new THREE.Mesh(wallGeoZ, wallMat);
            north.position.set(0, wallHeight / 2, -half);
            const south = north.clone();
            south.position.z = half;

            const west = new THREE.Mesh(wallGeoX, wallMat);
            west.position.set(-half, wallHeight / 2, 0);
            const east = west.clone();
            east.position.x = half;

            [north, south, west, east].forEach(w => {
                scene.add(w);
                walls.push(w);
            });

            // Holes positions (x, z, halfSize)
            const holeSpecs = [
                { x: -6, z: 6, halfSize: 2.5 },
                { x: 8,  z: -2, halfSize: 2.2 },
                { x: 0,  z: -8, halfSize: 3.0 }
            ];
            const holeMat = new THREE.MeshStandardMaterial({
                color: 0x050505,
                metalness: 0.1,
                roughness: 0.9
            });

            holeSpecs.forEach(h => {
                const hg = new THREE.BoxGeometry(h.halfSize * 2, 0.05, h.halfSize * 2);
                const mesh = new THREE.Mesh(hg, holeMat);
                mesh.position.set(h.x, 0.01, h.z);
                scene.add(mesh);
                holes.push({ mesh, x: h.x, z: h.z, halfSize: h.halfSize });
            });
        }

        // ------------------------------------------------------------
        // Mode switching
        // ------------------------------------------------------------
        function setMode(prototype) {
            isPrototypeMode = prototype;
            btnPrototype.classList.toggle("active", prototype);
            btnFull.classList.toggle("active", !prototype);

            resetGameState();
            clearDynamicObjects();

            if (isPrototypeMode) {
                createPrototypePlayerAndMeteors();
                setPrototypeMaterials();
                statusMessage.textContent = "Prototype mode: primitive geometries only.";
            } else {
                createFullPlayerAndMeteors();
                setFullMaterialsAndTextures();
                statusMessage.textContent = "Full mode: using loaded model(s) and textures.";
            }
        }

        function resetGameState() {
            isGameOver = false;
            score = 0;
            scoreDisplay.textContent = "Score: 0.0";
            statusMessage.textContent = "";
        }

        function clearDynamicObjects() {
            if (player) {
                scene.remove(player);
                player = null;
            }
            meteors.forEach(m => scene.remove(m));
            meteors = [];

            // NEW: clear shadows
            meteorShadows.forEach(s => scene.remove(s));
            meteorShadows = [];
        }

        function createPrototypePlayerAndMeteors() {
            const playerGeo = new THREE.BoxGeometry(1.5, 1, 2);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            player = new THREE.Mesh(playerGeo, playerMat);
            player.position.set(0, 1, 0);
            scene.add(player);

            const meteorGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const shadowGeo = new THREE.CircleGeometry(0.9, 16);

            for (let i = 0; i < meteorCount; i++) {
                const mat = new THREE.MeshStandardMaterial({ color: 0xff6347 });
                const mesh = new THREE.Mesh(meteorGeo, mat);
                resetMeteorPosition(mesh, true);
                scene.add(mesh);
                meteors.push(mesh);

                // NEW: shadow disk
                const shadowMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.35
                });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                scene.add(shadow);
                meteorShadows.push(shadow);
            }
        }

        function createFullPlayerAndMeteors() {
            const fallbackPlayer = createFallbackFullPlayer();
            player = fallbackPlayer;
            scene.add(player);

            if (gltfLoader) {
                // TODO: change path to your real .glb model
                gltfLoader.load(
                    "assets/models/spaceship.glb",
                    function (gltf) {
                        if (player) scene.remove(player);
                        player = gltf.scene;
                        player.traverse(obj => {
                            if (obj.isMesh) {
                                obj.castShadow = true;
                                obj.receiveShadow = true;
                            }
                        });
                        player.scale.set(1.8, 1.8, 1.8);
                        player.position.set(0, 1, 0);
                        scene.add(player);
                    },
                    undefined,
                    function (err) {
                        console.warn("Could not load spaceship model, using fallback rocket.", err);
                    }
                );
            }

            const meteorGeo = new THREE.SphereGeometry(0.8, 24, 24);
            const shadowGeo = new THREE.CircleGeometry(0.9, 16);

            // TODO: change path if your texture is elsewhere
            const rockTexture = textureLoader.load(
                "assets/textures/rock.jpg",
                function () {},
                undefined,
                function () {
                    console.warn("Could not load rock texture, using plain color.");
                }
            );

            for (let i = 0; i < meteorCount; i++) {
                const mat = new THREE.MeshStandardMaterial({
                    map: rockTexture,
                    color: 0xffffff
                });
                const mesh = new THREE.Mesh(meteorGeo, mat);
                resetMeteorPosition(mesh, true);
                scene.add(mesh);
                meteors.push(mesh);

                // NEW: shadow disk
                const shadowMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.35
                });
                const shadow = new THREE.Mesh(shadowGeo, shadowMat);
                shadow.rotation.x = -Math.PI / 2;
                shadow.position.set(mesh.position.x, 0.02, mesh.position.z);
                scene.add(shadow);
                meteorShadows.push(shadow);
            }
        }

        function createFallbackFullPlayer() {
            const bodyGeo = new THREE.CylinderGeometry(0.5, 0.8, 2.2, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00bcd4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);

            const noseGeo = new THREE.ConeGeometry(0.5, 1.0, 12);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.y = 1.5;

            const group = new THREE.Group();
            group.add(body);
            group.add(nose);
            group.position.set(0, 1, 0);
            return group;
        }

        function setPrototypeMaterials() {
            if (platform && platform.material) {
                platform.material = new THREE.MeshStandardMaterial({ color: 0x222222 });
            }
            if (skySphere && skySphere.material) {
                skySphere.material = new THREE.MeshBasicMaterial({
                    color: 0x050818,
                    side: THREE.BackSide
                });
            }
        }

        function setFullMaterialsAndTextures() {
            const floorTex = textureLoader.load(
                "assets/textures/metal_floor.jpg",
                function () {},
                undefined,
                function () {
                    console.warn("Could not load floor texture, using color.");
                }
            );

            if (platform && platform.material) {
                platform.material = new THREE.MeshStandardMaterial({
                    map: floorTex,
                    color: 0xffffff,
                    metalness: 0.4,
                    roughness: 0.6
                });
            }

            if (skySphere && skySphere.material) {
                skySphere.material = new THREE.MeshBasicMaterial({
                    color: 0x050818,
                    side: THREE.BackSide
                });
            }
        }

        // ------------------------------------------------------------
        // Input handling
        // ------------------------------------------------------------
        function setupInput() {
            window.addEventListener("keydown", onKeyDown);
            window.addEventListener("keyup", onKeyUp);

            btnPrototype.addEventListener("click", () => setMode(true));
            btnFull.addEventListener("click", () => setMode(false));

            const controlButtons = document.querySelectorAll("#controls button[data-dir]");
            controlButtons.forEach(btn => {
                const dir = btn.getAttribute("data-dir");

                function pressHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, true);
                }

                function releaseHandler(e) {
                    e.preventDefault();
                    setMoveState(dir, false);
                }

                btn.addEventListener("mousedown", pressHandler);
                btn.addEventListener("mouseup", releaseHandler);
                btn.addEventListener("mouseleave", releaseHandler);

                btn.addEventListener("touchstart", pressHandler, { passive: false });
                btn.addEventListener("touchend", releaseHandler, { passive: false });
                btn.addEventListener("touchcancel", releaseHandler, { passive: false });
            });
        }

        function onKeyDown(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = true;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = true;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = true;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = true;

            if (e.key === "r" || e.key === "R") {
                resetGameState();
                clearDynamicObjects();
                if (isPrototypeMode) {
                    createPrototypePlayerAndMeteors();
                    setPrototypeMaterials();
                } else {
                    createFullPlayerAndMeteors();
                    setFullMaterialsAndTextures();
                }
            }
        }

        function onKeyUp(e) {
            if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") moveState.left = false;
            if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") moveState.right = false;
            if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") moveState.forward = false;
            if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") moveState.backward = false;
        }

        function setMoveState(dir, value) {
            if (dir === "left") moveState.left = value;
            if (dir === "right") moveState.right = value;
            if (dir === "up") moveState.forward = value;
            if (dir === "down") moveState.backward = value;
        }

        // ------------------------------------------------------------
        // Game loop
        // ------------------------------------------------------------
        function animate(timestamp) {
            requestAnimationFrame(animate);

            const t = timestamp * 0.001;
            const delta = lastTime ? t - lastTime : 0;
            lastTime = t;

            if (!isGameOver) {
                updatePlayer(delta);
                updateMeteors(delta);
                checkCollisions();

                score += delta;
                scoreDisplay.textContent = "Score: " + score.toFixed(1);
            }

            renderer.render(scene, camera);
        }

        function updatePlayer(delta) {
            if (!player) return;

            // Input in "screen" space: ix = left/right, iz = up/down (forward/back)
            let ix = 0;
            let iz = 0;

            if (moveState.left)  ix -= 1;
            if (moveState.right) ix += 1;
            if (moveState.forward)  iz += 1;   // W / ArrowUp -> move "up" on screen
            if (moveState.backward) iz -= 1;   // S / ArrowDown -> move "down" on screen

            if (ix === 0 && iz === 0) {
                return;
            }

            // normalize
            const len = Math.sqrt(ix * ix + iz * iz);
            ix /= len;
            iz /= len;

            // world movement based on camera basis:
            // right/left along camRight, up/down along camForward
            const worldMove = new THREE.Vector3();
            worldMove.copy(camRight).multiplyScalar(ix);
            worldMove.addScaledVector(camForward, iz);

            const dist = playerSpeed * delta;
            const newX = player.position.x + worldMove.x * dist;
            const newZ = player.position.z + worldMove.z * dist;

            const half = worldSize * 0.5 - 1.0;
            player.position.x = THREE.MathUtils.clamp(newX, -half, half);
            player.position.z = THREE.MathUtils.clamp(newZ, -half, half);

            const maxTilt = 0.35;
            const targetTiltZ = THREE.MathUtils.clamp(-ix * maxTilt, -maxTilt, maxTilt);
            const targetTiltX = THREE.MathUtils.clamp(-iz * maxTilt, -maxTilt, maxTilt);

            player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, targetTiltZ, 0.15);
            player.rotation.x = THREE.MathUtils.lerp(player.rotation.x, targetTiltX, 0.15);

            // check if player is in any hole
            if (!isGameOver && isInHole(player.position.x, player.position.z)) {
                gameOver("You fell into a hole!");
            }
        }

        function updateMeteors(delta) {
            const speedBoost = score * 0.15;
            const fallSpeed = baseMeteorSpeed + speedBoost;

            for (let i = 0; i < meteors.length; i++) {
                const m = meteors[i];
                const s = meteorShadows[i];

                m.position.y -= fallSpeed * delta;
                m.rotation.x += 0.8 * delta;
                m.rotation.y += 0.5 * delta;

                if (m.position.y < -4) {
                    resetMeteorPosition(m, false);
                }

                // NEW: update shadow position/scale/opacity
                if (s) {
                    s.position.x = m.position.x;
                    s.position.z = m.position.z;

                    // t = 0 (low) -> big dark shadow; t = 1 (high) -> small faint shadow
                    const t = THREE.MathUtils.clamp((m.position.y - 2) / 18, 0, 1);
                    const scale = THREE.MathUtils.lerp(1.5, 0.4, t);
                    s.scale.set(scale, scale, 1);

                    const mat = s.material;
                    mat.opacity = THREE.MathUtils.lerp(0.55, 0.15, t);
                }
            }
        }

        function resetMeteorPosition(meteor, randomHeight) {
            const half = worldSize * 0.5 - 1.5;
            meteor.position.x = THREE.MathUtils.randFloat(-half, half);
            meteor.position.z = THREE.MathUtils.randFloat(-half, half);
            meteor.position.y = randomHeight
                ? THREE.MathUtils.randFloat(6, 24)
                : THREE.MathUtils.randFloat(14, 26);
        }

        function checkCollisions() {
            if (!player) return;

            const playerPos = new THREE.Vector3();
            player.getWorldPosition(playerPos);

            const playerRadius = 0.9;
            const meteorRadius = 0.8;

            for (const m of meteors) {
                const meteorPos = new THREE.Vector3();
                m.getWorldPosition(meteorPos);

                const dist = playerPos.distanceTo(meteorPos);
                if (dist < playerRadius + meteorRadius) {
                    gameOver("Hit by a meteor!");
                    break;
                }
            }
        }

        function isInHole(x, z) {
            for (const h of holes) {
                if (Math.abs(x - h.x) < h.halfSize &&
                    Math.abs(z - h.z) < h.halfSize) {
                    return true;
                }
            }
            return false;
        }

        function gameOver(reason) {
            if (isGameOver) return;
            isGameOver = true;
            const base = "Game over! Final score " + score.toFixed(1) + ".";
            const reasonText = reason ? " " + reason : "";
            statusMessage.textContent =
                base + reasonText + " Press R or switch mode to restart.";
        }

        // ------------------------------------------------------------
        // Resize
        // ------------------------------------------------------------
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });
    </script>
</body>
</html>
